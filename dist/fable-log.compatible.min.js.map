{"version":3,"sources":["fable-log.compatible.min.js","node_modules/browser-pack/_prelude.js","node_modules/fable-serviceproviderbase/source/Fable-ServiceProviderBase-Preinit.js","node_modules/fable-serviceproviderbase/source/Fable-ServiceProviderBase.js","node_modules/path-browserify/index.js","node_modules/process/browser.js","source/Fable-Log-BaseLogger.js","source/Fable-Log-DefaultProviders-Web.js","source/Fable-Log-DefaultStreams.json","source/Fable-Log-Logger-Console.js","source/Fable-Log-Logger-SimpleFlatFile.js","source/Fable-Log.js"],"names":["_get","Reflect","get","bind","target","property","receiver","base","_superPropBase","desc","Object","getOwnPropertyDescriptor","call","arguments","length","value","apply","this","object","prototype","hasOwnProperty","_getPrototypeOf","_inherits","subClass","superClass","TypeError","create","constructor","writable","configurable","defineProperty","_setPrototypeOf","o","p","setPrototypeOf","__proto__","_createSuper","Derived","hasNativeReflectConstruct","_isNativeReflectConstruct","result","Super","NewTarget","construct","_possibleConstructorReturn","self","_typeof","_assertThisInitialized","ReferenceError","sham","Proxy","Boolean","valueOf","e","getPrototypeOf","_classCallCheck","instance","Constructor","_defineProperties","props","i","descriptor","enumerable","_toPropertyKey","key","_createClass","protoProps","staticProps","_defineProperty","obj","arg","_toPrimitive","String","input","hint","prim","Symbol","toPrimitive","undefined","res","Number","iterator","f","exports","module","define","amd","window","global","FableLog","r","n","t","c","require","u","a","Error","code","FableCoreServiceProviderBase","pOptions","pServiceHash","fable","options","serviceType","UUID","concat","Math","floor","random","Hash","pFable","FableServiceProviderBase","isFable","getUUID","log","servicesMap","services","CoreServiceProviderBase","process","assertPath","path","JSON","stringify","normalizeStringPosix","allowAboveRoot","lastSegmentLength","lastSlash","dots","charCodeAt","lastSlashIndex","lastIndexOf","slice","posix","resolve","cwd","resolvedPath","resolvedAbsolute","normalize","isAbsolute","trailingSeparator","join","joined","relative","from","to","fromStart","fromEnd","fromLen","toStart","toLen","lastCommonSep","fromCode","out","_makeLong","dirname","hasRoot","end","matchedSlash","basename","ext","start","extIdx","firstNonSlashEnd","extname","startDot","startPart","preDotState","format","pathObject","sep","dir","root","name","_format","parse","ret","delimiter","win32","_process","cachedSetTimeout","cachedClearTimeout","defaultSetTimout","defaultClearTimeout","runTimeout","fun","setTimeout","clearTimeout","currentQueue","queue","draining","queueIndex","cleanUpNextTick","drainQueue","timeout","len","run","marker","runClearTimeout","Item","array","noop","nextTick","args","Array","push","title","browser","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","chdir","umask","BaseLogger","_libFableServiceProvi","_super","pLogStreamSettings","pLogStreamHash","_this","_Settings","loggerUUID","generateInsecureUUID","levels","tmpDate","Date","getTime","replace","pCharacter","tmpRandomData","toString","pLogText","pLogObject","write","pLogLevel","tmpDefaultProviders","console","loggertype","streamtype","level","ConsoleLogger","_libBaseLogger","_super2","pFableLog","_this2","_ShowTimeStamps","showtimestamps","_FormattedTimeStamps","formattedtimestamps","_ContextMessage","Context","Product","_OutputLogLinesToConsole","outputloglinestoconsole","_OutputObjectsToConsole","outputobjectstoconsole","prefixCache","pLevel","pObject","tmpTimeStamp","toISOString","tmpLogLine","libConsoleLog","libFS","libPath","SimpleFlatFileLogger","_libConsoleLog","_super3","_this3","logFileRawPath","logFilePath","logFileStreamOptions","fileStreamOptions","flags","encoding","fileWriter","createWriteStream","activelyWriting","logLineStrings","logObjectStrings","defaultWriteCompleteCallback","defaultBufferFlushCallback","fCloseComplete","tmpCloseComplete","fFlushComplete","tmpFlushComplete","flushBufferToLogFile","tmpLineStrings","tmpObjectStrings","tmpConstructedBufferOutputString","completeBufferFlushToLogFile","fs","_libFableServiceProvi2","_super4","pSettings","_this4","tmpSettings","_Providers","_StreamDefinitions","LogStreams","logStreams","logProviders","activeLogStreams","logStreamsTrace","logStreamsDebug","logStreamsInfo","logStreamsWarn","logStreamsError","logStreamsFatal","datumDecorator","pDatum","uuid","pLogger","fDatumDecorator","pMessage","tmpDecoratedDatum","trace","debug","info","warn","error","fatal","tmpStreamDefinition","assign","addLogger","initialize","tmpMessage","tmpTime","pTimeStamp","pTimeDelta","tmpEndTime","tmpMs","parseInt","tmpSeconds","tmpMinutes","tmpHours","pStartTime","logTimeDelta","getTimeDelta","logTimeDeltaHuman","LogProviderBase","LogProviderConsole"],"mappings":"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","file":"fable-log.compatible.min.js","sourcesContent":["(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.FableLog = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\n\n},{}],2:[function(require,module,exports){\n/**\n* Fable Core Pre-initialization Service Base\n*\n* For a couple services, we need to be able to instantiate them before the Fable object is fully initialized.\n* This is a base class for those services.\n*\n* @author <steven@velozo.com>\n*/\n\nclass FableCoreServiceProviderBase\n{\n\tconstructor(pOptions, pServiceHash)\n\t{\n\t\tthis.fable = false;\n\n\t\tthis.options = (typeof(pOptions) === 'object') ? pOptions : {};\n\n\t\tthis.serviceType = 'Unknown';\n\n\t\t// The hash will be a non-standard UUID ... the UUID service uses this base class!\n\t\tthis.UUID = `CORESVC-${Math.floor((Math.random() * (99999 - 10000)) + 10000)}`;\n\n\t\tthis.Hash = (typeof(pServiceHash) === 'string') ? pServiceHash : `${this.UUID}`;\n\t}\n\n\n\tstatic isFableService = true;\n\n\t// After fable is initialized, it would be expected to be wired in as a normal service.\n\tconnectFable(pFable)\n\t{\n\t\tthis.fable = pFable;\n\n\t\treturn true;\n\t}\n}\n\nmodule.exports = FableCoreServiceProviderBase;\n\n},{}],3:[function(require,module,exports){\n/**\n* Fable Service Base\n* @author <steven@velozo.com>\n*/\n\nclass FableServiceProviderBase\n{\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tthis.fable = pFable;\n\n\t\tthis.options = (typeof(pOptions) === 'object') ? pOptions\n\t\t\t\t\t\t: ((typeof(pFable) === 'object') && !pFable.isFable) ? pFable\n\t\t\t\t\t\t: {};\n\n\t\tthis.serviceType = 'Unknown';\n\n\t\tif (typeof(pFable.getUUID) == 'function')\n\t\t{\n\t\t\tthis.UUID = pFable.getUUID();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.UUID = `NoFABLESVC-${Math.floor((Math.random() * (99999 - 10000)) + 10000)}`\n\t\t}\n\n\t\tthis.Hash = (typeof(pServiceHash) === 'string') ? pServiceHash : `${this.UUID}`;\n\n\t\t// Pull back a few things\n\t\tthis.log = this.fable.log;\n\t\tthis.servicesMap = this.fable.servicesMap;\n\t\tthis.services = this.fable.services;\n\t}\n\n\tstatic isFableService = true;\n}\n\nmodule.exports = FableServiceProviderBase;\n\nmodule.exports.CoreServiceProviderBase = require('./Fable-ServiceProviderBase-Preinit.js');\n},{\"./Fable-ServiceProviderBase-Preinit.js\":2}],4:[function(require,module,exports){\n(function (process){(function (){\n// 'path' module extracted from Node.js v8.11.1 (only the posix part)\n// transplited with Babel\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));\n  }\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path, allowAboveRoot) {\n  var res = '';\n  var lastSegmentLength = 0;\n  var lastSlash = -1;\n  var dots = 0;\n  var code;\n  for (var i = 0; i <= path.length; ++i) {\n    if (i < path.length)\n      code = path.charCodeAt(i);\n    else if (code === 47 /*/*/)\n      break;\n    else\n      code = 47 /*/*/;\n    if (code === 47 /*/*/) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {\n          if (res.length > 2) {\n            var lastSlashIndex = res.lastIndexOf('/');\n            if (lastSlashIndex !== res.length - 1) {\n              if (lastSlashIndex === -1) {\n                res = '';\n                lastSegmentLength = 0;\n              } else {\n                res = res.slice(0, lastSlashIndex);\n                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');\n              }\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0)\n            res += '/..';\n          else\n            res = '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0)\n          res += '/' + path.slice(lastSlash + 1, i);\n        else\n          res = path.slice(lastSlash + 1, i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46 /*.*/ && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\nfunction _format(sep, pathObject) {\n  var dir = pathObject.dir || pathObject.root;\n  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');\n  if (!dir) {\n    return base;\n  }\n  if (dir === pathObject.root) {\n    return dir + base;\n  }\n  return dir + sep + base;\n}\n\nvar posix = {\n  // path.resolve([from ...], to)\n  resolve: function resolve() {\n    var resolvedPath = '';\n    var resolvedAbsolute = false;\n    var cwd;\n\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      var path;\n      if (i >= 0)\n        path = arguments[i];\n      else {\n        if (cwd === undefined)\n          cwd = process.cwd();\n        path = cwd;\n      }\n\n      assertPath(path);\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = path + '/' + resolvedPath;\n      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    }\n\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);\n\n    if (resolvedAbsolute) {\n      if (resolvedPath.length > 0)\n        return '/' + resolvedPath;\n      else\n        return '/';\n    } else if (resolvedPath.length > 0) {\n      return resolvedPath;\n    } else {\n      return '.';\n    }\n  },\n\n  normalize: function normalize(path) {\n    assertPath(path);\n\n    if (path.length === 0) return '.';\n\n    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;\n\n    // Normalize the path\n    path = normalizeStringPosix(path, !isAbsolute);\n\n    if (path.length === 0 && !isAbsolute) path = '.';\n    if (path.length > 0 && trailingSeparator) path += '/';\n\n    if (isAbsolute) return '/' + path;\n    return path;\n  },\n\n  isAbsolute: function isAbsolute(path) {\n    assertPath(path);\n    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;\n  },\n\n  join: function join() {\n    if (arguments.length === 0)\n      return '.';\n    var joined;\n    for (var i = 0; i < arguments.length; ++i) {\n      var arg = arguments[i];\n      assertPath(arg);\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = arg;\n        else\n          joined += '/' + arg;\n      }\n    }\n    if (joined === undefined)\n      return '.';\n    return posix.normalize(joined);\n  },\n\n  relative: function relative(from, to) {\n    assertPath(from);\n    assertPath(to);\n\n    if (from === to) return '';\n\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to) return '';\n\n    // Trim any leading backslashes\n    var fromStart = 1;\n    for (; fromStart < from.length; ++fromStart) {\n      if (from.charCodeAt(fromStart) !== 47 /*/*/)\n        break;\n    }\n    var fromEnd = from.length;\n    var fromLen = fromEnd - fromStart;\n\n    // Trim any leading backslashes\n    var toStart = 1;\n    for (; toStart < to.length; ++toStart) {\n      if (to.charCodeAt(toStart) !== 47 /*/*/)\n        break;\n    }\n    var toEnd = to.length;\n    var toLen = toEnd - toStart;\n\n    // Compare paths to find the longest common path from root\n    var length = fromLen < toLen ? fromLen : toLen;\n    var lastCommonSep = -1;\n    var i = 0;\n    for (; i <= length; ++i) {\n      if (i === length) {\n        if (toLen > length) {\n          if (to.charCodeAt(toStart + i) === 47 /*/*/) {\n            // We get here if `from` is the exact base path for `to`.\n            // For example: from='/foo/bar'; to='/foo/bar/baz'\n            return to.slice(toStart + i + 1);\n          } else if (i === 0) {\n            // We get here if `from` is the root\n            // For example: from='/'; to='/foo'\n            return to.slice(toStart + i);\n          }\n        } else if (fromLen > length) {\n          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {\n            // We get here if `to` is the exact base path for `from`.\n            // For example: from='/foo/bar/baz'; to='/foo/bar'\n            lastCommonSep = i;\n          } else if (i === 0) {\n            // We get here if `to` is the root.\n            // For example: from='/foo'; to='/'\n            lastCommonSep = 0;\n          }\n        }\n        break;\n      }\n      var fromCode = from.charCodeAt(fromStart + i);\n      var toCode = to.charCodeAt(toStart + i);\n      if (fromCode !== toCode)\n        break;\n      else if (fromCode === 47 /*/*/)\n        lastCommonSep = i;\n    }\n\n    var out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {\n        if (out.length === 0)\n          out += '..';\n        else\n          out += '/..';\n      }\n    }\n\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0)\n      return out + to.slice(toStart + lastCommonSep);\n    else {\n      toStart += lastCommonSep;\n      if (to.charCodeAt(toStart) === 47 /*/*/)\n        ++toStart;\n      return to.slice(toStart);\n    }\n  },\n\n  _makeLong: function _makeLong(path) {\n    return path;\n  },\n\n  dirname: function dirname(path) {\n    assertPath(path);\n    if (path.length === 0) return '.';\n    var code = path.charCodeAt(0);\n    var hasRoot = code === 47 /*/*/;\n    var end = -1;\n    var matchedSlash = true;\n    for (var i = path.length - 1; i >= 1; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          if (!matchedSlash) {\n            end = i;\n            break;\n          }\n        } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) return hasRoot ? '/' : '.';\n    if (hasRoot && end === 1) return '//';\n    return path.slice(0, end);\n  },\n\n  basename: function basename(path, ext) {\n    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('\"ext\" argument must be a string');\n    assertPath(path);\n\n    var start = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i;\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext.length === path.length && ext === path) return '';\n      var extIdx = ext.length - 1;\n      var firstNonSlashEnd = -1;\n      for (i = path.length - 1; i >= 0; --i) {\n        var code = path.charCodeAt(i);\n        if (code === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;\n      return path.slice(start, end);\n    } else {\n      for (i = path.length - 1; i >= 0; --i) {\n        if (path.charCodeAt(i) === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else if (end === -1) {\n          // We saw the first non-path separator, mark this as the end of our\n          // path component\n          matchedSlash = false;\n          end = i + 1;\n        }\n      }\n\n      if (end === -1) return '';\n      return path.slice(start, end);\n    }\n  },\n\n  extname: function extname(path) {\n    assertPath(path);\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n    for (var i = path.length - 1; i >= 0; --i) {\n      var code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1)\n            startDot = i;\n          else if (preDotState !== 1)\n            preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return '';\n    }\n    return path.slice(startDot, end);\n  },\n\n  format: function format(pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n      throw new TypeError('The \"pathObject\" argument must be of type Object. Received type ' + typeof pathObject);\n    }\n    return _format('/', pathObject);\n  },\n\n  parse: function parse(path) {\n    assertPath(path);\n\n    var ret = { root: '', dir: '', base: '', ext: '', name: '' };\n    if (path.length === 0) return ret;\n    var code = path.charCodeAt(0);\n    var isAbsolute = code === 47 /*/*/;\n    var start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;\n        } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n    // We saw a non-dot character immediately before the dot\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly '..'\n    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path.slice(1, startDot);\n        ret.base = path.slice(1, end);\n      } else {\n        ret.name = path.slice(startPart, startDot);\n        ret.base = path.slice(startPart, end);\n      }\n      ret.ext = path.slice(startDot, end);\n    }\n\n    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';\n\n    return ret;\n  },\n\n  sep: '/',\n  delimiter: ':',\n  win32: null,\n  posix: null\n};\n\nposix.posix = posix;\n\nmodule.exports = posix;\n\n}).call(this)}).call(this,require('_process'))\n\n},{\"_process\":5}],5:[function(require,module,exports){\n// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n},{}],6:[function(require,module,exports){\n/**\n* Base Logger Class\n*\n*\n* @author Steven Velozo <steven@velozo.com>\n*/\n\nconst libFableServiceProviderBase = require('fable-serviceproviderbase').CoreServiceProviderBase;\n\nclass BaseLogger extends libFableServiceProviderBase\n{\n\tconstructor(pLogStreamSettings, pLogStreamHash)\n\t{\n\t\tsuper(pLogStreamSettings, pLogStreamHash);\n\t\t// This should not possibly be able to be instantiated without a settings object\n\t\tthis._Settings = (typeof(pLogStreamSettings) == 'object') ? pLogStreamSettings : {};\n\n\t\tthis.serviceType = 'Logging-Provider';\n\n\t\t// The base logger does nothing but associate a UUID with itself\n\t\t// We added this as the mechanism for tracking loggers to allow multiple simultaneous streams\n\t\t// to the same provider.\n\t\tthis.loggerUUID = this.generateInsecureUUID();\n\n\t\t// Eventually we can use this array to ompute which levels the provider allows.\n\t\t// For now it's just used to precompute some string concatenations.\n\t\tthis.levels = (\n\t\t\t[\n\t\t\t\t\"trace\",\n\t\t\t\t\"debug\",\n\t\t\t\t\"info\",\n\t\t\t\t\"warn\",\n\t\t\t\t\"error\",\n\t\t\t\t\"fatal\"\n\t\t\t]);\n\t}\n\n\t// This is meant to generate programmatically insecure UUIDs to identify loggers\n\tgenerateInsecureUUID()\n\t{\n\t\tlet tmpDate = new Date().getTime();\n\t\tlet tmpUUID = 'LOGSTREAM-xxxxxx-yxxxxx'.replace(/[xy]/g,\n\t\t\t\t(pCharacter) =>\n\t\t\t\t{\n\t\t\t\t\t// Funny algorithm from w3resource that is twister-ish without the deep math and security\n\t\t\t\t\t// ..but good enough for unique log stream identifiers\n\t\t\t\t\tlet tmpRandomData = (tmpDate + Math.random()*16)%16 | 0;\n\t\t\t\t\ttmpDate = Math.floor(tmpDate/16);\n\n\t\t\t\t\treturn (pCharacter =='x' ? tmpRandomData : (tmpRandomData&0x3|0x8)).toString(16);\n\t\t\t\t});\n\t\treturn tmpUUID;\n\t}\n\n\tinitialize()\n\t{\n\t\t// No operation.\n\t}\n\n\ttrace(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"trace\", pLogText, pLogObject);\n\t}\n\n\tdebug(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"debug\", pLogText, pLogObject);\n\t}\n\n\tinfo(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"info\", pLogText, pLogObject);\n\t}\n\n\twarn(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"warn\", pLogText, pLogObject);\n\t}\n\n\terror(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"error\", pLogText, pLogObject);\n\t}\n\n\tfatal(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"fatal\", pLogText, pLogObject);\n\t}\n\n\twrite(pLogLevel, pLogText, pLogObject)\n\t{\n\t\t// The base logger does nothing.\n\t\treturn true;\n\t}\n}\n\nmodule.exports = BaseLogger;\n\n},{\"fable-serviceproviderbase\":3}],7:[function(require,module,exports){\n/**\n* Default Logger Provider Function\n*\n*\n* @author Steven Velozo <steven@velozo.com>\n*/\n\n// Return the providers that are available without extensions loaded\nvar getDefaultProviders = () =>\n{\n\tlet tmpDefaultProviders = {};\n\n\ttmpDefaultProviders.console = require('./Fable-Log-Logger-Console.js');\n\n\ttmpDefaultProviders.default = tmpDefaultProviders.console;\n\n\treturn tmpDefaultProviders;\n}\n\nmodule.exports = getDefaultProviders();\n},{\"./Fable-Log-Logger-Console.js\":9}],8:[function(require,module,exports){\nmodule.exports=[\n    {\n        \"loggertype\": \"console\",\n        \"streamtype\": \"console\",\n        \"level\": \"trace\"\n    }\n]\n},{}],9:[function(require,module,exports){\nlet libBaseLogger = require('./Fable-Log-BaseLogger.js');\n\nclass ConsoleLogger extends libBaseLogger\n{\n\tconstructor(pLogStreamSettings, pFableLog)\n\t{\n\t\tsuper(pLogStreamSettings);\n\n\t\tthis._ShowTimeStamps = this._Settings.hasOwnProperty('showtimestamps') ? (this._Settings.showtimestamps == true) : true;\n\t\tthis._FormattedTimeStamps = this._Settings.hasOwnProperty('formattedtimestamps') ? (this._Settings.formattedtimestamps == true) : true;\n\n\t\tthis._ContextMessage = this._Settings.hasOwnProperty('Context') ? `(${this._Settings.Context})` :\n\t\t\t\t\t\t\t\tpFableLog._Settings.hasOwnProperty('Product') ? `(${pFableLog._Settings.Product})` :\n\t\t\t\t\t\t\t\t'Unnamed_Log_Context';\n\n\t\t// Allow the user to decide what gets output to the console\n\t\tthis._OutputLogLinesToConsole = this._Settings.hasOwnProperty('outputloglinestoconsole') ? this._Settings.outputloglinestoconsole : true;\n\t\tthis._OutputObjectsToConsole = this._Settings.hasOwnProperty('outputobjectstoconsole') ? this._Settings.outputobjectstoconsole : true;\n\n\t\t// Precompute the prefix for each level\n\t\tthis.prefixCache = {};\n\t\tfor (let i = 0; i <= this.levels.length; i++)\n\t\t{\n\t\t\tthis.prefixCache[this.levels[i]] = `[${this.levels[i]}] ${this._ContextMessage}: `;\n\n\t\t\tif (this._ShowTimeStamps)\n\t\t\t{\n\t\t\t\t// If there is a timestamp we need a to prepend space before the prefixcache string, since the timestamp comes first\n\t\t\t\tthis.prefixCache[this.levels[i]] = ' '+this.prefixCache[this.levels[i]];\n\t\t\t}\n\t\t}\n\t}\n\n\twrite(pLevel, pLogText, pObject)\n\t{\n\t\tlet tmpTimeStamp = '';\n\t\tif (this._ShowTimeStamps && this._FormattedTimeStamps)\n\t\t{\n\t\t\ttmpTimeStamp = (new Date()).toISOString();\n\t\t}\n\t\telse if (this._ShowTimeStamps)\n\t\t{\n\t\t\ttmpTimeStamp = +new Date();\n\t\t}\n\n\t\tlet tmpLogLine = `${tmpTimeStamp}${this.prefixCache[pLevel]}${pLogText}`;\n\n\t\tif (this._OutputLogLinesToConsole)\n\t\t{\n\t\t\tconsole.log(tmpLogLine);\n\t\t}\n\n\t\t// Write out the object on a separate line if it is passed in\n\t\tif (this._OutputObjectsToConsole && (typeof(pObject) !== 'undefined'))\n\t\t{\n\t\t\tconsole.log(JSON.stringify(pObject, null, 2));\n\t\t}\n\n\t\t// Provide an easy way to be overridden and be consistent\n\t\treturn tmpLogLine;\n\t}\n}\n\nmodule.exports = ConsoleLogger;\n},{\"./Fable-Log-BaseLogger.js\":6}],10:[function(require,module,exports){\nconst libConsoleLog = require('./Fable-Log-Logger-Console.js');\nconst libFS = require('fs');\nconst libPath = require('path');\n\nclass SimpleFlatFileLogger extends libConsoleLog\n{\n\tconstructor(pLogStreamSettings, pFableLog)\n\t{\n\t\tsuper(pLogStreamSettings, pFableLog);\n\n\t\t// If a path isn't provided for the logfile, it tries to use the ProductName or Context\n\t\tthis.logFileRawPath = (this._Settings.hasOwnProperty('path')) ? this._Settings.path : `./${this._ContextMessage}.log`;\n\t\tthis.logFilePath = libPath.normalize(this.logFileRawPath);\n\n\t\tthis.logFileStreamOptions = (this._Settings.hasOwnProperty('fileStreamoptions')) ? this._Settings.fileStreamOptions : (\n\t\t\t{\n\t\t\t\t\"flags\": \"a\",\n\t\t\t\t\"encoding\": \"utf8\"\n\t\t\t})\n\n\t\tthis.fileWriter = libFS.createWriteStream(this.logFilePath, this.logFileStreamOptions);\n\n\t\tthis.activelyWriting = false;\n\n\t\tthis.logLineStrings = [];\n\t\tthis.logObjectStrings = [];\n\n\t\tthis.defaultWriteCompleteCallback = ()=>{};\n\t\tthis.defaultBufferFlushCallback = ()=>{};\n\t}\n\n\tcloseWriter(fCloseComplete)\n\t{\n\t\tlet tmpCloseComplete = (typeof(fCloseComplete) == 'function') ? fCloseComplete : ()=>{};\n\t\tif (this.fileWriter)\n\t\t{\n\t\t\tthis.fileWriter.end('\\n');\n\t\t\treturn this.fileWriter.once('finish', tmpCloseComplete.bind(this));\n\t\t}\n\t}\n\n\tcompleteBufferFlushToLogFile(fFlushComplete)\n\t{\n\t\tthis.activelyWriting = false;\n\t\tlet tmpFlushComplete = (typeof(fFlushComplete) == 'function') ? fFlushComplete : this.defaultBufferFlushCallback;\n\n\t\tif (this.logLineStrings.length > 0)\n\t\t{\n\t\t\tthis.flushBufferToLogFile(tmpFlushComplete);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn tmpFlushComplete();\n\t\t}\n\t}\n\n\tflushBufferToLogFile(fFlushComplete)\n\t{\n\t\tif (!this.activelyWriting)\n\t\t{\n\t\t\t// Only want to be writing one thing at a time....\n\t\t\tthis.activelyWriting = true;\n\n\t\t\tlet tmpFlushComplete = (typeof(fFlushComplete) == 'function') ? fFlushComplete : this.defaultBufferFlushCallback;\n\n\t\t\t// Get the current buffer arrays.  These should always have matching number of elements.\n\t\t\tlet tmpLineStrings = this.logLineStrings;\n\t\t\tlet tmpObjectStrings = this.logObjectStrings;\n\n\t\t\t// Reset these to be filled while we process this queue...\n\t\t\tthis.logLineStrings = [];\n\t\t\tthis.logObjectStrings = [];\n\n\t\t\t// This is where we will put each line before writing it to the file...\n\t\t\tlet tmpConstructedBufferOutputString = '';\n\n\t\t\tfor (let i = 0; i < tmpLineStrings.length; i++)\n\t\t\t{\n\t\t\t\t// TODO: Windows Newline?   ....... yo no se!\n\t\t\t\ttmpConstructedBufferOutputString += `${tmpLineStrings[i]}\\n`;\n\t\t\t\tif (tmpObjectStrings[i] !== false)\n\t\t\t\t{\n\t\t\t\t\ttmpConstructedBufferOutputString += `${tmpObjectStrings[i]}\\n`;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!this.fileWriter.write(tmpConstructedBufferOutputString, 'utf8'))\n\t\t\t{\n\t\t\t\t// If the streamwriter returns false, we need to wait for it to drain.\n\t\t\t\tthis.fileWriter.once('drain', this.completeBufferFlushToLogFile.bind(this, tmpFlushComplete));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn this.completeBufferFlushToLogFile(tmpFlushComplete);\n\t\t\t}\n\t\t}\n\t}\n\n\twrite(pLevel, pLogText, pObject)\n\t{\n\t\tlet tmpLogLine = super.write(pLevel, pLogText, pObject);\n\n\t\t// Use a very simple array as the write buffer\n\t\tthis.logLineStrings.push(tmpLogLine);\n\n\t\t// Write out the object on a separate line if it is passed in\n\t\tif (typeof(pObject) !== 'undefined')\n\t\t{\n\t\t\tthis.logObjectStrings.push(JSON.stringify(pObject, null, 4));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.logObjectStrings.push(false);\n\t\t}\n\n\t\tthis.flushBufferToLogFile();\n\t}\n}\n\nmodule.exports = SimpleFlatFileLogger;\n},{\"./Fable-Log-Logger-Console.js\":9,\"fs\":1,\"path\":4}],11:[function(require,module,exports){\n/**\n* Fable Logging Service\n*/\n\nconst libFableServiceProviderBase = require('fable-serviceproviderbase').CoreServiceProviderBase;\n\nclass FableLog extends libFableServiceProviderBase\n{\n\tconstructor(pSettings, pServiceHash)\n\t{\n\t\tsuper(pSettings, pServiceHash);\n\n\t\tthis.serviceType = 'Logging';\n\n\t\tlet tmpSettings = (typeof(pSettings) === 'object') ? pSettings : {}\n\t\tthis._Settings = tmpSettings;\n\n\t\tthis._Providers = require('./Fable-Log-DefaultProviders-Node.js');\n\n\t\tthis._StreamDefinitions = (tmpSettings.hasOwnProperty('LogStreams')) ? tmpSettings.LogStreams : require('./Fable-Log-DefaultStreams.json');\n\n\t\tthis.logStreams = [];\n\n\t\t// This object gets decorated for one-time instantiated providers that\n\t\t//  have multiple outputs, such as bunyan.\n\t\tthis.logProviders = {};\n\n\t\t// A hash list of the GUIDs for each log stream, so they can't be added to the set more than one time\n\t\tthis.activeLogStreams = {};\n\n\t\tthis.logStreamsTrace = [];\n\t\tthis.logStreamsDebug = [];\n\t\tthis.logStreamsInfo = [];\n\t\tthis.logStreamsWarn = [];\n\t\tthis.logStreamsError = [];\n\t\tthis.logStreamsFatal = [];\n\n\t\tthis.datumDecorator = (pDatum) => pDatum;\n\n\t\tthis.uuid = (typeof(tmpSettings.Product) === 'string') ? tmpSettings.Product : 'Default';\n\t}\n\n\taddLogger(pLogger, pLevel)\n\t{\n\t\t// Bail out if we've already created one.\n\t\tif (this.activeLogStreams.hasOwnProperty(pLogger.loggerUUID))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\t// Add it to the streams and to the mutex\n\t\tthis.logStreams.push(pLogger);\n\t\tthis.activeLogStreams[pLogger.loggerUUID] = true;\n\n\t\t// Make sure a kosher level was passed in\n\t\tswitch (pLevel)\n\t\t{\n\t\t\tcase 'trace':\n\t\t\t\tthis.logStreamsTrace.push(pLogger);\n\t\t\tcase 'debug':\n\t\t\t\tthis.logStreamsDebug.push(pLogger);\n\t\t\tcase 'info':\n\t\t\t\tthis.logStreamsInfo.push(pLogger);\n\t\t\tcase 'warn':\n\t\t\t\tthis.logStreamsWarn.push(pLogger);\n\t\t\tcase 'error':\n\t\t\t\tthis.logStreamsError.push(pLogger);\n\t\t\tcase 'fatal':\n\t\t\t\tthis.logStreamsFatal.push(pLogger);\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tsetDatumDecorator(fDatumDecorator)\n\t{\n\t\tif (typeof(fDatumDecorator) === 'function')\n\t\t{\n\t\t\tthis.datumDecorator = fDatumDecorator;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.datumDecorator = (pDatum) => pDatum;\n\t\t}\n\t}\n\n\ttrace(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsTrace.length; i++)\n\t\t{\n\t\t\tthis.logStreamsTrace[i].trace(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\tdebug(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsDebug.length; i++)\n\t\t{\n\t\t\tthis.logStreamsDebug[i].debug(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\tinfo(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsInfo.length; i++)\n\t\t{\n\t\t\tthis.logStreamsInfo[i].info(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\twarn(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsWarn.length; i++)\n\t\t{\n\t\t\tthis.logStreamsWarn[i].warn(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\terror(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsError.length; i++)\n\t\t{\n\t\t\tthis.logStreamsError[i].error(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\tfatal(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsFatal.length; i++)\n\t\t{\n\t\t\tthis.logStreamsFatal[i].fatal(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\tinitialize()\n\t{\n\t\t// \"initialize\" each logger as defined in the logging parameters\n\t\tfor (let i = 0; i < this._StreamDefinitions.length; i++)\n\t\t{\n\t\t\tlet tmpStreamDefinition = Object.assign({loggertype:'default',streamtype:'console',level:'info'},this._StreamDefinitions[i]);\n\n\t\t\tif (!this._Providers.hasOwnProperty(tmpStreamDefinition.loggertype))\n\t\t\t{\n\t\t\t\tconsole.log(`Error initializing log stream: bad loggertype in stream definition ${JSON.stringify(tmpStreamDefinition)}`);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.addLogger(new this._Providers[tmpStreamDefinition.loggertype](tmpStreamDefinition, this), tmpStreamDefinition.level);\n\t\t\t}\n\t\t}\n\n\t\t// Now initialize each one.\n\t\tfor (let i = 0; i < this.logStreams.length; i++)\n\t\t{\n\t\t\tthis.logStreams[i].initialize();\n\t\t}\n\t}\n\n\tlogTime(pMessage, pDatum)\n\t{\n\t\tlet tmpMessage = (typeof(pMessage) !== 'undefined') ? pMessage : 'Time';\n\t\tlet tmpTime = new Date();\n\t\tthis.info(`${tmpMessage} ${tmpTime} (epoch ${+tmpTime})`, pDatum);\n\t}\n\n\t// Get a timestamp\n\tgetTimeStamp()\n\t{\n\t\treturn +new Date();\n\t}\n\n\tgetTimeDelta(pTimeStamp)\n\t{\n\t\tlet tmpEndTime = +new Date();\n\t\treturn tmpEndTime-pTimeStamp;\n\t}\n\n\t// Log the delta between a timestamp, and now with a message\n\tlogTimeDelta(pTimeDelta, pMessage, pDatum)\n\t{\n\t\tlet tmpMessage = (typeof(pMessage) !== 'undefined') ? pMessage : 'Time Measurement';\n\t\tlet tmpDatum = (typeof(pDatum) === 'object') ? pDatum : {};\n\n\t\tlet tmpEndTime = +new Date();\n\n\t\tthis.info(`${tmpMessage} logged at (epoch ${+tmpEndTime}) took (${pTimeDelta}ms)`, pDatum);\n\t}\n\n\tlogTimeDeltaHuman(pTimeDelta, pMessage, pDatum)\n\t{\n\t\tlet tmpMessage = (typeof(pMessage) !== 'undefined') ? pMessage : 'Time Measurement';\n\n\t\tlet tmpEndTime = +new Date();\n\n\t\tlet tmpMs = parseInt(pTimeDelta%1000);\n\t\tlet tmpSeconds = parseInt((pTimeDelta/1000)%60);\n\t\tlet tmpMinutes = parseInt((pTimeDelta/(1000*60))%60);\n\t\tlet tmpHours = parseInt(pTimeDelta/(1000*60*60));\n\n\t\ttmpMs = (tmpMs < 10) ? \"00\"+tmpMs : (tmpMs < 100) ? \"0\"+tmpMs : tmpMs;\n\t\ttmpSeconds = (tmpSeconds < 10) ? \"0\"+tmpSeconds : tmpSeconds;\n\t\ttmpMinutes = (tmpMinutes < 10) ? \"0\"+tmpMinutes : tmpMinutes;\n\t\ttmpHours = (tmpHours < 10) ? \"0\"+tmpHours : tmpHours;\n\n\t\tthis.info(`${tmpMessage} logged at (epoch ${+tmpEndTime}) took (${pTimeDelta}ms) or (${tmpHours}:${tmpMinutes}:${tmpSeconds}.${tmpMs})`, pDatum);\n\t}\n\n\tlogTimeDeltaRelative(pStartTime, pMessage, pDatum)\n\t{\n\t\tthis.logTimeDelta(this.getTimeDelta(pStartTime), pMessage, pDatum);\n\t}\n\n\tlogTimeDeltaRelativeHuman(pStartTime, pMessage, pDatum)\n\t{\n\t\tthis.logTimeDeltaHuman(this.getTimeDelta(pStartTime), pMessage, pDatum);\n\t}\n}\n\nmodule.exports = FableLog;\nmodule.exports.LogProviderBase = require('./Fable-Log-BaseLogger.js');\nmodule.exports.LogProviderConsole = require('./Fable-Log-Logger-Console.js');\nmodule.exports.LogProviderConsole = require('./Fable-Log-Logger-SimpleFlatFile.js');\n\n},{\"./Fable-Log-BaseLogger.js\":6,\"./Fable-Log-DefaultProviders-Node.js\":7,\"./Fable-Log-DefaultStreams.json\":8,\"./Fable-Log-Logger-Console.js\":9,\"./Fable-Log-Logger-SimpleFlatFile.js\":10,\"fable-serviceproviderbase\":3}]},{},[11])(11)\n});\n\n","(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","/**\n* Fable Core Pre-initialization Service Base\n*\n* For a couple services, we need to be able to instantiate them before the Fable object is fully initialized.\n* This is a base class for those services.\n*\n* @author <steven@velozo.com>\n*/\n\nclass FableCoreServiceProviderBase\n{\n\tconstructor(pOptions, pServiceHash)\n\t{\n\t\tthis.fable = false;\n\n\t\tthis.options = (typeof(pOptions) === 'object') ? pOptions : {};\n\n\t\tthis.serviceType = 'Unknown';\n\n\t\t// The hash will be a non-standard UUID ... the UUID service uses this base class!\n\t\tthis.UUID = `CORESVC-${Math.floor((Math.random() * (99999 - 10000)) + 10000)}`;\n\n\t\tthis.Hash = (typeof(pServiceHash) === 'string') ? pServiceHash : `${this.UUID}`;\n\t}\n\n\n\tstatic isFableService = true;\n\n\t// After fable is initialized, it would be expected to be wired in as a normal service.\n\tconnectFable(pFable)\n\t{\n\t\tthis.fable = pFable;\n\n\t\treturn true;\n\t}\n}\n\nmodule.exports = FableCoreServiceProviderBase;\n","/**\n* Fable Service Base\n* @author <steven@velozo.com>\n*/\n\nclass FableServiceProviderBase\n{\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tthis.fable = pFable;\n\n\t\tthis.options = (typeof(pOptions) === 'object') ? pOptions\n\t\t\t\t\t\t: ((typeof(pFable) === 'object') && !pFable.isFable) ? pFable\n\t\t\t\t\t\t: {};\n\n\t\tthis.serviceType = 'Unknown';\n\n\t\tif (typeof(pFable.getUUID) == 'function')\n\t\t{\n\t\t\tthis.UUID = pFable.getUUID();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.UUID = `NoFABLESVC-${Math.floor((Math.random() * (99999 - 10000)) + 10000)}`\n\t\t}\n\n\t\tthis.Hash = (typeof(pServiceHash) === 'string') ? pServiceHash : `${this.UUID}`;\n\n\t\t// Pull back a few things\n\t\tthis.log = this.fable.log;\n\t\tthis.servicesMap = this.fable.servicesMap;\n\t\tthis.services = this.fable.services;\n\t}\n\n\tstatic isFableService = true;\n}\n\nmodule.exports = FableServiceProviderBase;\n\nmodule.exports.CoreServiceProviderBase = require('./Fable-ServiceProviderBase-Preinit.js');","// 'path' module extracted from Node.js v8.11.1 (only the posix part)\n// transplited with Babel\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));\n  }\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path, allowAboveRoot) {\n  var res = '';\n  var lastSegmentLength = 0;\n  var lastSlash = -1;\n  var dots = 0;\n  var code;\n  for (var i = 0; i <= path.length; ++i) {\n    if (i < path.length)\n      code = path.charCodeAt(i);\n    else if (code === 47 /*/*/)\n      break;\n    else\n      code = 47 /*/*/;\n    if (code === 47 /*/*/) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {\n          if (res.length > 2) {\n            var lastSlashIndex = res.lastIndexOf('/');\n            if (lastSlashIndex !== res.length - 1) {\n              if (lastSlashIndex === -1) {\n                res = '';\n                lastSegmentLength = 0;\n              } else {\n                res = res.slice(0, lastSlashIndex);\n                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');\n              }\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0)\n            res += '/..';\n          else\n            res = '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0)\n          res += '/' + path.slice(lastSlash + 1, i);\n        else\n          res = path.slice(lastSlash + 1, i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46 /*.*/ && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\nfunction _format(sep, pathObject) {\n  var dir = pathObject.dir || pathObject.root;\n  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');\n  if (!dir) {\n    return base;\n  }\n  if (dir === pathObject.root) {\n    return dir + base;\n  }\n  return dir + sep + base;\n}\n\nvar posix = {\n  // path.resolve([from ...], to)\n  resolve: function resolve() {\n    var resolvedPath = '';\n    var resolvedAbsolute = false;\n    var cwd;\n\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      var path;\n      if (i >= 0)\n        path = arguments[i];\n      else {\n        if (cwd === undefined)\n          cwd = process.cwd();\n        path = cwd;\n      }\n\n      assertPath(path);\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = path + '/' + resolvedPath;\n      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    }\n\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);\n\n    if (resolvedAbsolute) {\n      if (resolvedPath.length > 0)\n        return '/' + resolvedPath;\n      else\n        return '/';\n    } else if (resolvedPath.length > 0) {\n      return resolvedPath;\n    } else {\n      return '.';\n    }\n  },\n\n  normalize: function normalize(path) {\n    assertPath(path);\n\n    if (path.length === 0) return '.';\n\n    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;\n\n    // Normalize the path\n    path = normalizeStringPosix(path, !isAbsolute);\n\n    if (path.length === 0 && !isAbsolute) path = '.';\n    if (path.length > 0 && trailingSeparator) path += '/';\n\n    if (isAbsolute) return '/' + path;\n    return path;\n  },\n\n  isAbsolute: function isAbsolute(path) {\n    assertPath(path);\n    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;\n  },\n\n  join: function join() {\n    if (arguments.length === 0)\n      return '.';\n    var joined;\n    for (var i = 0; i < arguments.length; ++i) {\n      var arg = arguments[i];\n      assertPath(arg);\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = arg;\n        else\n          joined += '/' + arg;\n      }\n    }\n    if (joined === undefined)\n      return '.';\n    return posix.normalize(joined);\n  },\n\n  relative: function relative(from, to) {\n    assertPath(from);\n    assertPath(to);\n\n    if (from === to) return '';\n\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to) return '';\n\n    // Trim any leading backslashes\n    var fromStart = 1;\n    for (; fromStart < from.length; ++fromStart) {\n      if (from.charCodeAt(fromStart) !== 47 /*/*/)\n        break;\n    }\n    var fromEnd = from.length;\n    var fromLen = fromEnd - fromStart;\n\n    // Trim any leading backslashes\n    var toStart = 1;\n    for (; toStart < to.length; ++toStart) {\n      if (to.charCodeAt(toStart) !== 47 /*/*/)\n        break;\n    }\n    var toEnd = to.length;\n    var toLen = toEnd - toStart;\n\n    // Compare paths to find the longest common path from root\n    var length = fromLen < toLen ? fromLen : toLen;\n    var lastCommonSep = -1;\n    var i = 0;\n    for (; i <= length; ++i) {\n      if (i === length) {\n        if (toLen > length) {\n          if (to.charCodeAt(toStart + i) === 47 /*/*/) {\n            // We get here if `from` is the exact base path for `to`.\n            // For example: from='/foo/bar'; to='/foo/bar/baz'\n            return to.slice(toStart + i + 1);\n          } else if (i === 0) {\n            // We get here if `from` is the root\n            // For example: from='/'; to='/foo'\n            return to.slice(toStart + i);\n          }\n        } else if (fromLen > length) {\n          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {\n            // We get here if `to` is the exact base path for `from`.\n            // For example: from='/foo/bar/baz'; to='/foo/bar'\n            lastCommonSep = i;\n          } else if (i === 0) {\n            // We get here if `to` is the root.\n            // For example: from='/foo'; to='/'\n            lastCommonSep = 0;\n          }\n        }\n        break;\n      }\n      var fromCode = from.charCodeAt(fromStart + i);\n      var toCode = to.charCodeAt(toStart + i);\n      if (fromCode !== toCode)\n        break;\n      else if (fromCode === 47 /*/*/)\n        lastCommonSep = i;\n    }\n\n    var out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {\n        if (out.length === 0)\n          out += '..';\n        else\n          out += '/..';\n      }\n    }\n\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0)\n      return out + to.slice(toStart + lastCommonSep);\n    else {\n      toStart += lastCommonSep;\n      if (to.charCodeAt(toStart) === 47 /*/*/)\n        ++toStart;\n      return to.slice(toStart);\n    }\n  },\n\n  _makeLong: function _makeLong(path) {\n    return path;\n  },\n\n  dirname: function dirname(path) {\n    assertPath(path);\n    if (path.length === 0) return '.';\n    var code = path.charCodeAt(0);\n    var hasRoot = code === 47 /*/*/;\n    var end = -1;\n    var matchedSlash = true;\n    for (var i = path.length - 1; i >= 1; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          if (!matchedSlash) {\n            end = i;\n            break;\n          }\n        } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) return hasRoot ? '/' : '.';\n    if (hasRoot && end === 1) return '//';\n    return path.slice(0, end);\n  },\n\n  basename: function basename(path, ext) {\n    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('\"ext\" argument must be a string');\n    assertPath(path);\n\n    var start = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i;\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext.length === path.length && ext === path) return '';\n      var extIdx = ext.length - 1;\n      var firstNonSlashEnd = -1;\n      for (i = path.length - 1; i >= 0; --i) {\n        var code = path.charCodeAt(i);\n        if (code === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;\n      return path.slice(start, end);\n    } else {\n      for (i = path.length - 1; i >= 0; --i) {\n        if (path.charCodeAt(i) === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else if (end === -1) {\n          // We saw the first non-path separator, mark this as the end of our\n          // path component\n          matchedSlash = false;\n          end = i + 1;\n        }\n      }\n\n      if (end === -1) return '';\n      return path.slice(start, end);\n    }\n  },\n\n  extname: function extname(path) {\n    assertPath(path);\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n    for (var i = path.length - 1; i >= 0; --i) {\n      var code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1)\n            startDot = i;\n          else if (preDotState !== 1)\n            preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return '';\n    }\n    return path.slice(startDot, end);\n  },\n\n  format: function format(pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n      throw new TypeError('The \"pathObject\" argument must be of type Object. Received type ' + typeof pathObject);\n    }\n    return _format('/', pathObject);\n  },\n\n  parse: function parse(path) {\n    assertPath(path);\n\n    var ret = { root: '', dir: '', base: '', ext: '', name: '' };\n    if (path.length === 0) return ret;\n    var code = path.charCodeAt(0);\n    var isAbsolute = code === 47 /*/*/;\n    var start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;\n        } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n    // We saw a non-dot character immediately before the dot\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly '..'\n    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path.slice(1, startDot);\n        ret.base = path.slice(1, end);\n      } else {\n        ret.name = path.slice(startPart, startDot);\n        ret.base = path.slice(startPart, end);\n      }\n      ret.ext = path.slice(startDot, end);\n    }\n\n    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';\n\n    return ret;\n  },\n\n  sep: '/',\n  delimiter: ':',\n  win32: null,\n  posix: null\n};\n\nposix.posix = posix;\n\nmodule.exports = posix;\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","/**\n* Base Logger Class\n*\n*\n* @author Steven Velozo <steven@velozo.com>\n*/\n\nconst libFableServiceProviderBase = require('fable-serviceproviderbase').CoreServiceProviderBase;\n\nclass BaseLogger extends libFableServiceProviderBase\n{\n\tconstructor(pLogStreamSettings, pLogStreamHash)\n\t{\n\t\tsuper(pLogStreamSettings, pLogStreamHash);\n\t\t// This should not possibly be able to be instantiated without a settings object\n\t\tthis._Settings = (typeof(pLogStreamSettings) == 'object') ? pLogStreamSettings : {};\n\n\t\tthis.serviceType = 'Logging-Provider';\n\n\t\t// The base logger does nothing but associate a UUID with itself\n\t\t// We added this as the mechanism for tracking loggers to allow multiple simultaneous streams\n\t\t// to the same provider.\n\t\tthis.loggerUUID = this.generateInsecureUUID();\n\n\t\t// Eventually we can use this array to ompute which levels the provider allows.\n\t\t// For now it's just used to precompute some string concatenations.\n\t\tthis.levels = (\n\t\t\t[\n\t\t\t\t\"trace\",\n\t\t\t\t\"debug\",\n\t\t\t\t\"info\",\n\t\t\t\t\"warn\",\n\t\t\t\t\"error\",\n\t\t\t\t\"fatal\"\n\t\t\t]);\n\t}\n\n\t// This is meant to generate programmatically insecure UUIDs to identify loggers\n\tgenerateInsecureUUID()\n\t{\n\t\tlet tmpDate = new Date().getTime();\n\t\tlet tmpUUID = 'LOGSTREAM-xxxxxx-yxxxxx'.replace(/[xy]/g,\n\t\t\t\t(pCharacter) =>\n\t\t\t\t{\n\t\t\t\t\t// Funny algorithm from w3resource that is twister-ish without the deep math and security\n\t\t\t\t\t// ..but good enough for unique log stream identifiers\n\t\t\t\t\tlet tmpRandomData = (tmpDate + Math.random()*16)%16 | 0;\n\t\t\t\t\ttmpDate = Math.floor(tmpDate/16);\n\n\t\t\t\t\treturn (pCharacter =='x' ? tmpRandomData : (tmpRandomData&0x3|0x8)).toString(16);\n\t\t\t\t});\n\t\treturn tmpUUID;\n\t}\n\n\tinitialize()\n\t{\n\t\t// No operation.\n\t}\n\n\ttrace(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"trace\", pLogText, pLogObject);\n\t}\n\n\tdebug(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"debug\", pLogText, pLogObject);\n\t}\n\n\tinfo(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"info\", pLogText, pLogObject);\n\t}\n\n\twarn(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"warn\", pLogText, pLogObject);\n\t}\n\n\terror(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"error\", pLogText, pLogObject);\n\t}\n\n\tfatal(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"fatal\", pLogText, pLogObject);\n\t}\n\n\twrite(pLogLevel, pLogText, pLogObject)\n\t{\n\t\t// The base logger does nothing.\n\t\treturn true;\n\t}\n}\n\nmodule.exports = BaseLogger;\n","/**\n* Default Logger Provider Function\n*\n*\n* @author Steven Velozo <steven@velozo.com>\n*/\n\n// Return the providers that are available without extensions loaded\nvar getDefaultProviders = () =>\n{\n\tlet tmpDefaultProviders = {};\n\n\ttmpDefaultProviders.console = require('./Fable-Log-Logger-Console.js');\n\n\ttmpDefaultProviders.default = tmpDefaultProviders.console;\n\n\treturn tmpDefaultProviders;\n}\n\nmodule.exports = getDefaultProviders();","module.exports=[\n    {\n        \"loggertype\": \"console\",\n        \"streamtype\": \"console\",\n        \"level\": \"trace\"\n    }\n]","let libBaseLogger = require('./Fable-Log-BaseLogger.js');\n\nclass ConsoleLogger extends libBaseLogger\n{\n\tconstructor(pLogStreamSettings, pFableLog)\n\t{\n\t\tsuper(pLogStreamSettings);\n\n\t\tthis._ShowTimeStamps = this._Settings.hasOwnProperty('showtimestamps') ? (this._Settings.showtimestamps == true) : true;\n\t\tthis._FormattedTimeStamps = this._Settings.hasOwnProperty('formattedtimestamps') ? (this._Settings.formattedtimestamps == true) : true;\n\n\t\tthis._ContextMessage = this._Settings.hasOwnProperty('Context') ? `(${this._Settings.Context})` :\n\t\t\t\t\t\t\t\tpFableLog._Settings.hasOwnProperty('Product') ? `(${pFableLog._Settings.Product})` :\n\t\t\t\t\t\t\t\t'Unnamed_Log_Context';\n\n\t\t// Allow the user to decide what gets output to the console\n\t\tthis._OutputLogLinesToConsole = this._Settings.hasOwnProperty('outputloglinestoconsole') ? this._Settings.outputloglinestoconsole : true;\n\t\tthis._OutputObjectsToConsole = this._Settings.hasOwnProperty('outputobjectstoconsole') ? this._Settings.outputobjectstoconsole : true;\n\n\t\t// Precompute the prefix for each level\n\t\tthis.prefixCache = {};\n\t\tfor (let i = 0; i <= this.levels.length; i++)\n\t\t{\n\t\t\tthis.prefixCache[this.levels[i]] = `[${this.levels[i]}] ${this._ContextMessage}: `;\n\n\t\t\tif (this._ShowTimeStamps)\n\t\t\t{\n\t\t\t\t// If there is a timestamp we need a to prepend space before the prefixcache string, since the timestamp comes first\n\t\t\t\tthis.prefixCache[this.levels[i]] = ' '+this.prefixCache[this.levels[i]];\n\t\t\t}\n\t\t}\n\t}\n\n\twrite(pLevel, pLogText, pObject)\n\t{\n\t\tlet tmpTimeStamp = '';\n\t\tif (this._ShowTimeStamps && this._FormattedTimeStamps)\n\t\t{\n\t\t\ttmpTimeStamp = (new Date()).toISOString();\n\t\t}\n\t\telse if (this._ShowTimeStamps)\n\t\t{\n\t\t\ttmpTimeStamp = +new Date();\n\t\t}\n\n\t\tlet tmpLogLine = `${tmpTimeStamp}${this.prefixCache[pLevel]}${pLogText}`;\n\n\t\tif (this._OutputLogLinesToConsole)\n\t\t{\n\t\t\tconsole.log(tmpLogLine);\n\t\t}\n\n\t\t// Write out the object on a separate line if it is passed in\n\t\tif (this._OutputObjectsToConsole && (typeof(pObject) !== 'undefined'))\n\t\t{\n\t\t\tconsole.log(JSON.stringify(pObject, null, 2));\n\t\t}\n\n\t\t// Provide an easy way to be overridden and be consistent\n\t\treturn tmpLogLine;\n\t}\n}\n\nmodule.exports = ConsoleLogger;","const libConsoleLog = require('./Fable-Log-Logger-Console.js');\nconst libFS = require('fs');\nconst libPath = require('path');\n\nclass SimpleFlatFileLogger extends libConsoleLog\n{\n\tconstructor(pLogStreamSettings, pFableLog)\n\t{\n\t\tsuper(pLogStreamSettings, pFableLog);\n\n\t\t// If a path isn't provided for the logfile, it tries to use the ProductName or Context\n\t\tthis.logFileRawPath = (this._Settings.hasOwnProperty('path')) ? this._Settings.path : `./${this._ContextMessage}.log`;\n\t\tthis.logFilePath = libPath.normalize(this.logFileRawPath);\n\n\t\tthis.logFileStreamOptions = (this._Settings.hasOwnProperty('fileStreamoptions')) ? this._Settings.fileStreamOptions : (\n\t\t\t{\n\t\t\t\t\"flags\": \"a\",\n\t\t\t\t\"encoding\": \"utf8\"\n\t\t\t})\n\n\t\tthis.fileWriter = libFS.createWriteStream(this.logFilePath, this.logFileStreamOptions);\n\n\t\tthis.activelyWriting = false;\n\n\t\tthis.logLineStrings = [];\n\t\tthis.logObjectStrings = [];\n\n\t\tthis.defaultWriteCompleteCallback = ()=>{};\n\t\tthis.defaultBufferFlushCallback = ()=>{};\n\t}\n\n\tcloseWriter(fCloseComplete)\n\t{\n\t\tlet tmpCloseComplete = (typeof(fCloseComplete) == 'function') ? fCloseComplete : ()=>{};\n\t\tif (this.fileWriter)\n\t\t{\n\t\t\tthis.fileWriter.end('\\n');\n\t\t\treturn this.fileWriter.once('finish', tmpCloseComplete.bind(this));\n\t\t}\n\t}\n\n\tcompleteBufferFlushToLogFile(fFlushComplete)\n\t{\n\t\tthis.activelyWriting = false;\n\t\tlet tmpFlushComplete = (typeof(fFlushComplete) == 'function') ? fFlushComplete : this.defaultBufferFlushCallback;\n\n\t\tif (this.logLineStrings.length > 0)\n\t\t{\n\t\t\tthis.flushBufferToLogFile(tmpFlushComplete);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn tmpFlushComplete();\n\t\t}\n\t}\n\n\tflushBufferToLogFile(fFlushComplete)\n\t{\n\t\tif (!this.activelyWriting)\n\t\t{\n\t\t\t// Only want to be writing one thing at a time....\n\t\t\tthis.activelyWriting = true;\n\n\t\t\tlet tmpFlushComplete = (typeof(fFlushComplete) == 'function') ? fFlushComplete : this.defaultBufferFlushCallback;\n\n\t\t\t// Get the current buffer arrays.  These should always have matching number of elements.\n\t\t\tlet tmpLineStrings = this.logLineStrings;\n\t\t\tlet tmpObjectStrings = this.logObjectStrings;\n\n\t\t\t// Reset these to be filled while we process this queue...\n\t\t\tthis.logLineStrings = [];\n\t\t\tthis.logObjectStrings = [];\n\n\t\t\t// This is where we will put each line before writing it to the file...\n\t\t\tlet tmpConstructedBufferOutputString = '';\n\n\t\t\tfor (let i = 0; i < tmpLineStrings.length; i++)\n\t\t\t{\n\t\t\t\t// TODO: Windows Newline?   ....... yo no se!\n\t\t\t\ttmpConstructedBufferOutputString += `${tmpLineStrings[i]}\\n`;\n\t\t\t\tif (tmpObjectStrings[i] !== false)\n\t\t\t\t{\n\t\t\t\t\ttmpConstructedBufferOutputString += `${tmpObjectStrings[i]}\\n`;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!this.fileWriter.write(tmpConstructedBufferOutputString, 'utf8'))\n\t\t\t{\n\t\t\t\t// If the streamwriter returns false, we need to wait for it to drain.\n\t\t\t\tthis.fileWriter.once('drain', this.completeBufferFlushToLogFile.bind(this, tmpFlushComplete));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn this.completeBufferFlushToLogFile(tmpFlushComplete);\n\t\t\t}\n\t\t}\n\t}\n\n\twrite(pLevel, pLogText, pObject)\n\t{\n\t\tlet tmpLogLine = super.write(pLevel, pLogText, pObject);\n\n\t\t// Use a very simple array as the write buffer\n\t\tthis.logLineStrings.push(tmpLogLine);\n\n\t\t// Write out the object on a separate line if it is passed in\n\t\tif (typeof(pObject) !== 'undefined')\n\t\t{\n\t\t\tthis.logObjectStrings.push(JSON.stringify(pObject, null, 4));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.logObjectStrings.push(false);\n\t\t}\n\n\t\tthis.flushBufferToLogFile();\n\t}\n}\n\nmodule.exports = SimpleFlatFileLogger;","/**\n* Fable Logging Service\n*/\n\nconst libFableServiceProviderBase = require('fable-serviceproviderbase').CoreServiceProviderBase;\n\nclass FableLog extends libFableServiceProviderBase\n{\n\tconstructor(pSettings, pServiceHash)\n\t{\n\t\tsuper(pSettings, pServiceHash);\n\n\t\tthis.serviceType = 'Logging';\n\n\t\tlet tmpSettings = (typeof(pSettings) === 'object') ? pSettings : {}\n\t\tthis._Settings = tmpSettings;\n\n\t\tthis._Providers = require('./Fable-Log-DefaultProviders-Node.js');\n\n\t\tthis._StreamDefinitions = (tmpSettings.hasOwnProperty('LogStreams')) ? tmpSettings.LogStreams : require('./Fable-Log-DefaultStreams.json');\n\n\t\tthis.logStreams = [];\n\n\t\t// This object gets decorated for one-time instantiated providers that\n\t\t//  have multiple outputs, such as bunyan.\n\t\tthis.logProviders = {};\n\n\t\t// A hash list of the GUIDs for each log stream, so they can't be added to the set more than one time\n\t\tthis.activeLogStreams = {};\n\n\t\tthis.logStreamsTrace = [];\n\t\tthis.logStreamsDebug = [];\n\t\tthis.logStreamsInfo = [];\n\t\tthis.logStreamsWarn = [];\n\t\tthis.logStreamsError = [];\n\t\tthis.logStreamsFatal = [];\n\n\t\tthis.datumDecorator = (pDatum) => pDatum;\n\n\t\tthis.uuid = (typeof(tmpSettings.Product) === 'string') ? tmpSettings.Product : 'Default';\n\t}\n\n\taddLogger(pLogger, pLevel)\n\t{\n\t\t// Bail out if we've already created one.\n\t\tif (this.activeLogStreams.hasOwnProperty(pLogger.loggerUUID))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\t// Add it to the streams and to the mutex\n\t\tthis.logStreams.push(pLogger);\n\t\tthis.activeLogStreams[pLogger.loggerUUID] = true;\n\n\t\t// Make sure a kosher level was passed in\n\t\tswitch (pLevel)\n\t\t{\n\t\t\tcase 'trace':\n\t\t\t\tthis.logStreamsTrace.push(pLogger);\n\t\t\tcase 'debug':\n\t\t\t\tthis.logStreamsDebug.push(pLogger);\n\t\t\tcase 'info':\n\t\t\t\tthis.logStreamsInfo.push(pLogger);\n\t\t\tcase 'warn':\n\t\t\t\tthis.logStreamsWarn.push(pLogger);\n\t\t\tcase 'error':\n\t\t\t\tthis.logStreamsError.push(pLogger);\n\t\t\tcase 'fatal':\n\t\t\t\tthis.logStreamsFatal.push(pLogger);\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tsetDatumDecorator(fDatumDecorator)\n\t{\n\t\tif (typeof(fDatumDecorator) === 'function')\n\t\t{\n\t\t\tthis.datumDecorator = fDatumDecorator;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.datumDecorator = (pDatum) => pDatum;\n\t\t}\n\t}\n\n\ttrace(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsTrace.length; i++)\n\t\t{\n\t\t\tthis.logStreamsTrace[i].trace(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\tdebug(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsDebug.length; i++)\n\t\t{\n\t\t\tthis.logStreamsDebug[i].debug(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\tinfo(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsInfo.length; i++)\n\t\t{\n\t\t\tthis.logStreamsInfo[i].info(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\twarn(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsWarn.length; i++)\n\t\t{\n\t\t\tthis.logStreamsWarn[i].warn(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\terror(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsError.length; i++)\n\t\t{\n\t\t\tthis.logStreamsError[i].error(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\tfatal(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsFatal.length; i++)\n\t\t{\n\t\t\tthis.logStreamsFatal[i].fatal(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\tinitialize()\n\t{\n\t\t// \"initialize\" each logger as defined in the logging parameters\n\t\tfor (let i = 0; i < this._StreamDefinitions.length; i++)\n\t\t{\n\t\t\tlet tmpStreamDefinition = Object.assign({loggertype:'default',streamtype:'console',level:'info'},this._StreamDefinitions[i]);\n\n\t\t\tif (!this._Providers.hasOwnProperty(tmpStreamDefinition.loggertype))\n\t\t\t{\n\t\t\t\tconsole.log(`Error initializing log stream: bad loggertype in stream definition ${JSON.stringify(tmpStreamDefinition)}`);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.addLogger(new this._Providers[tmpStreamDefinition.loggertype](tmpStreamDefinition, this), tmpStreamDefinition.level);\n\t\t\t}\n\t\t}\n\n\t\t// Now initialize each one.\n\t\tfor (let i = 0; i < this.logStreams.length; i++)\n\t\t{\n\t\t\tthis.logStreams[i].initialize();\n\t\t}\n\t}\n\n\tlogTime(pMessage, pDatum)\n\t{\n\t\tlet tmpMessage = (typeof(pMessage) !== 'undefined') ? pMessage : 'Time';\n\t\tlet tmpTime = new Date();\n\t\tthis.info(`${tmpMessage} ${tmpTime} (epoch ${+tmpTime})`, pDatum);\n\t}\n\n\t// Get a timestamp\n\tgetTimeStamp()\n\t{\n\t\treturn +new Date();\n\t}\n\n\tgetTimeDelta(pTimeStamp)\n\t{\n\t\tlet tmpEndTime = +new Date();\n\t\treturn tmpEndTime-pTimeStamp;\n\t}\n\n\t// Log the delta between a timestamp, and now with a message\n\tlogTimeDelta(pTimeDelta, pMessage, pDatum)\n\t{\n\t\tlet tmpMessage = (typeof(pMessage) !== 'undefined') ? pMessage : 'Time Measurement';\n\t\tlet tmpDatum = (typeof(pDatum) === 'object') ? pDatum : {};\n\n\t\tlet tmpEndTime = +new Date();\n\n\t\tthis.info(`${tmpMessage} logged at (epoch ${+tmpEndTime}) took (${pTimeDelta}ms)`, pDatum);\n\t}\n\n\tlogTimeDeltaHuman(pTimeDelta, pMessage, pDatum)\n\t{\n\t\tlet tmpMessage = (typeof(pMessage) !== 'undefined') ? pMessage : 'Time Measurement';\n\n\t\tlet tmpEndTime = +new Date();\n\n\t\tlet tmpMs = parseInt(pTimeDelta%1000);\n\t\tlet tmpSeconds = parseInt((pTimeDelta/1000)%60);\n\t\tlet tmpMinutes = parseInt((pTimeDelta/(1000*60))%60);\n\t\tlet tmpHours = parseInt(pTimeDelta/(1000*60*60));\n\n\t\ttmpMs = (tmpMs < 10) ? \"00\"+tmpMs : (tmpMs < 100) ? \"0\"+tmpMs : tmpMs;\n\t\ttmpSeconds = (tmpSeconds < 10) ? \"0\"+tmpSeconds : tmpSeconds;\n\t\ttmpMinutes = (tmpMinutes < 10) ? \"0\"+tmpMinutes : tmpMinutes;\n\t\ttmpHours = (tmpHours < 10) ? \"0\"+tmpHours : tmpHours;\n\n\t\tthis.info(`${tmpMessage} logged at (epoch ${+tmpEndTime}) took (${pTimeDelta}ms) or (${tmpHours}:${tmpMinutes}:${tmpSeconds}.${tmpMs})`, pDatum);\n\t}\n\n\tlogTimeDeltaRelative(pStartTime, pMessage, pDatum)\n\t{\n\t\tthis.logTimeDelta(this.getTimeDelta(pStartTime), pMessage, pDatum);\n\t}\n\n\tlogTimeDeltaRelativeHuman(pStartTime, pMessage, pDatum)\n\t{\n\t\tthis.logTimeDeltaHuman(this.getTimeDelta(pStartTime), pMessage, pDatum);\n\t}\n}\n\nmodule.exports = FableLog;\nmodule.exports.LogProviderBase = require('./Fable-Log-BaseLogger.js');\nmodule.exports.LogProviderConsole = require('./Fable-Log-Logger-Console.js');\nmodule.exports.LogProviderConsole = require('./Fable-Log-Logger-SimpleFlatFile.js');\n"]}