{"version":3,"sources":["node_modules/browser-pack/_prelude.js","source/Fable-Log-BaseLogger.js","fable-log.min.js","source/Fable-Log-Browser-Shim.js","source/Fable-Log-DefaultProviders-Web.js","source/Fable-Log-DefaultStreams.json","source/Fable-Log-Logger-Console.js","source/Fable-Log.js"],"names":["f","exports","module","define","amd","window","global","self","this","FableLog","r","e","n","t","o","i","c","require","u","a","Error","code","p","call","length","constructor","pLogStreamSettings","pFableLog","_Settings","loggerUUID","generateInsecureUUID","levels","tmpDate","Date","getTime","replace","pCharacter","tmpRandomData","Math","random","floor","toString","initialize","trace","pLogText","pLogObject","write","debug","info","warn","error","fatal","pLogLevel","libNPMModuleWrapper","hasOwnProperty","getDefaultProviders","tmpDefaultProviders","console","default","loggertype","streamtype","level","libBaseLogger","super","_ShowTimeStamps","showtimestamps","_FormattedTimeStamps","formattedtimestamps","_ContextMessage","Context","Product","_OutputLogLinesToConsole","outputloglinestoconsole","_OutputObjectsToConsole","outputobjectstoconsole","prefixCache","pLevel","pObject","tmpTimeStamp","toISOString","tmpLogLine","log","JSON","stringify","pFableSettings","pFable","tmpSettings","_Providers","_StreamDefinitions","LogStreams","logStreams","logProviders","activeLogStreams","logStreamsTrace","logStreamsDebug","logStreamsInfo","logStreamsWarn","logStreamsError","logStreamsFatal","datumDecorator","pDatum","uuid","addLogger","pLogger","push","setDatumDecorator","fDatumDecorator","pMessage","tmpDecoratedDatum","tmpStreamDefinition","Object","assign","logTime","tmpMessage","tmpTime","getTimeStamp","getTimeDelta","pTimeStamp","logTimeDelta","pTimeDelta","tmpEndTime","logTimeDeltaHuman","tmpMs","parseInt","tmpSeconds","tmpMinutes","tmpHours","logTimeDeltaRelative","pStartTime","logTimeDeltaRelativeHuman","new","pSettings","LogProviderBase"],"mappings":"CAAA,SAAAA,GAAA,GAAA,iBAAAC,SAAA,oBAAAC,OAAAA,OAAAD,QAAAD,SAAA,GAAA,mBAAAG,QAAAA,OAAAC,IAAAD,OAAA,GAAAH,OAAA,EAAA,oBAAAK,OAAAA,OAAA,oBAAAC,OAAAA,OAAA,oBAAAC,KAAAA,KAAAC,MAAAC,SAAAT,GAAA,CAAA,CAAA,EAAA,WAAA,OAAA,SAAAU,EAAAC,EAAAC,EAAAC,GAAA,SAAAC,EAAAC,EAAAf,GAAA,IAAAY,EAAAG,GAAA,CAAA,IAAAJ,EAAAI,GAAA,CAAA,IAAAC,EAAA,mBAAAC,SAAAA,QAAA,IAAAjB,GAAAgB,EAAA,OAAAA,EAAAD,GAAA,GAAA,GAAAG,EAAA,OAAAA,EAAAH,GAAA,GAAA,IAAAI,EAAA,IAAAC,MAAA,uBAAAL,EAAA,KAAA,MAAAI,EAAAE,KAAA,mBAAAF,CAAA,CAAA,IAAAG,EAAAV,EAAAG,GAAA,CAAAd,QAAA,CAAA,GAAAU,EAAAI,GAAA,GAAAQ,KAAAD,EAAArB,SAAA,SAAAS,GAAA,OAAAI,EAAAH,EAAAI,GAAA,GAAAL,IAAAA,EAAA,GAAAY,EAAAA,EAAArB,QAAAS,EAAAC,EAAAC,EAAAC,EAAA,CAAA,OAAAD,EAAAG,GAAAd,OAAA,CAAA,IAAA,IAAAiB,EAAA,mBAAAD,SAAAA,QAAAF,EAAA,EAAAA,EAAAF,EAAAW,OAAAT,IAAAD,EAAAD,EAAAE,IAAA,OAAAD,CAAA,CAAA,CAAA,CAAA,EAAA,CAAA,SAAAG,EAAAf,EAAAD,GC4FAC,EAAAD;;;;;;;;AApFA,MAEAwB,YAAAC,EAAAC,GAGAnB,KAAAoB,UAAA,iBAAAF,EAAAA,EAAA,CAAA,EAKAlB,KAAAqB,WAAArB,KAAAsB,uBAIAtB,KAAAuB,OACA,CACA,QACA,QACA,OACA,OACA,QACA,QAEA,CAGAD,uBAEA,IAAAE,GAAA,IAAAC,MAAAC,UAWA,MAVA,0BAAAC,QAAA,SACAC,IAIA,IAAAC,GAAAL,EAAA,GAAAM,KAAAC,UAAA,GAAA,EAGA,OAFAP,EAAAM,KAAAE,MAAAR,EAAA,KAEA,KAAAI,EAAAC,EAAA,EAAAA,EAAA,GAAAI,SAAA,GAAA,GAGA,CAEAC,aAEA,CAGAC,MAAAC,EAAAC,GAEArC,KAAAsC,MAAA,QAAAF,EAAAC,EACA,CAEAE,MAAAH,EAAAC,GAEArC,KAAAsC,MAAA,QAAAF,EAAAC,EACA,CAEAG,KAAAJ,EAAAC,GAEArC,KAAAsC,MAAA,OAAAF,EAAAC,EACA,CAEAI,KAAAL,EAAAC,GAEArC,KAAAsC,MAAA,OAAAF,EAAAC,EACA,CAEAK,MAAAN,EAAAC,GAEArC,KAAAsC,MAAA,QAAAF,EAAAC,EACA,CAEAM,MAAAP,EAAAC,GAEArC,KAAAsC,MAAA,QAAAF,EAAAC,EACA,CAEAC,MAAAM,EAAAR,EAAAC,GAGA,OAAA,CACA,ECMA,EAAE,CAAC,GAAG,EAAE,CAAC,SAAS5B,EAAQf,EAAOD;;;;;;;ACzFjC,IAAAoD,EAAApC,EAAA,kBAEA,iBAAAZ,QAAAA,OAAAiD,eAAA,cAEAjD,OAAAI,SAAA4C,GAGAnD,EAAAD,QAAAoD,CDiGA,EAAE,CAAC,iBAAiB,IAAI,EAAE,CAAC,SAASpC,EAAQf,EAAOD;;;;;;;;AErGnDsD,oBAAAA,KAEA,IAAAC,EAAA,CAAA,EAMA,OAJAA,EAAAC,QAAAxC,EAAA,iCAEAuC,EAAAE,QAAAF,EAAAC,QAEAD,CAAA,EAGAtD,EAAAD,QAAAsD,qBFgHA,EAAE,CAAC,gCAAgC,IAAI,EAAE,CAAC,SAAStC,EAAQf,EAAOD,GGpIlEC,EAAAD,QAAA,CACA,CACA0D,WAAA,UACAC,WAAA,UACAC,MAAA,SHwIA,EAAE,CAAC,GAAG,EAAE,CAAC,SAAS5C,EAAQf,EAAOD,GI5IjC,IAAA6D,EAAA7C,EAAA,6BA+DAf,EAAAD,QA7DA,cAAA6D,EAEArC,YAAAC,EAAAC,GAEAoC,MAAArC,GAEAlB,KAAAwD,kBAAAxD,KAAAoB,UAAA0B,eAAA,mBAAA,GAAA9C,KAAAoB,UAAAqC,eACAzD,KAAA0D,uBAAA1D,KAAAoB,UAAA0B,eAAA,wBAAA,GAAA9C,KAAAoB,UAAAuC,oBAEA3D,KAAA4D,gBAAA5D,KAAAoB,UAAA0B,eAAA,WAAA,IAAA9C,KAAAoB,UAAAyC,WACA1C,EAAAC,UAAA0B,eAAA,WAAA,IAAA3B,EAAAC,UAAA0C,WACA,sBAGA9D,KAAA+D,0BAAA/D,KAAAoB,UAAA0B,eAAA,4BAAA9C,KAAAoB,UAAA4C,wBACAhE,KAAAiE,yBAAAjE,KAAAoB,UAAA0B,eAAA,2BAAA9C,KAAAoB,UAAA8C,uBAGAlE,KAAAmE,YAAA,CAAA,EACA,IAAA,IAAA5D,EAAA,EAAAA,GAAAP,KAAAuB,OAAAP,OAAAT,IAEAP,KAAAmE,YAAAnE,KAAAuB,OAAAhB,IAAA,IAAAP,KAAAuB,OAAAhB,OAAAP,KAAA4D,oBAEA5D,KAAAwD,kBAGAxD,KAAAmE,YAAAnE,KAAAuB,OAAAhB,IAAA,IAAAP,KAAAmE,YAAAnE,KAAAuB,OAAAhB,IAGA,CAEA+B,MAAA8B,EAAAhC,EAAAiC,GAEA,IAAAC,EAAA,GACAtE,KAAAwD,iBAAAxD,KAAA0D,qBAEAY,GAAA,IAAA7C,MAAA8C,cAEAvE,KAAAwD,kBAEAc,GAAA,IAAA7C,MAGA,IAAA+C,EAAA,GAAAF,IAAAtE,KAAAmE,YAAAC,KAAAhC,IAcA,OAZApC,KAAA+D,0BAEAd,QAAAwB,IAAAD,GAIAxE,KAAAiE,8BAAA,IAAAI,GAEApB,QAAAwB,IAAAC,KAAAC,UAAAN,EAAA,KAAA,IAIAG,CACA,EJiJA,EAAE,CAAC,4BAA4B,IAAI,EAAE,CAAC,SAAS/D,EAAQf,EAAOD;;;;;;;;;AK9L9D,MAAAQ,EAEAgB,YAAA2D,EAAAC,GAEA,IAAAC,EAAA,iBAAAF,EAAAA,EAAA,CAAA,EACA5E,KAAAoB,UAAA0D,EAEA9E,KAAA+E,WAAAtE,EAAA,wCAEAT,KAAAgF,mBAAAF,EAAAhC,eAAA,cAAAgC,EAAAG,WAAAxE,EAAA,mCAEAT,KAAAkF,WAAA,GAIAlF,KAAAmF,aAAA,CAAA,EAGAnF,KAAAoF,iBAAA,CAAA,EAEApF,KAAAqF,gBAAA,GACArF,KAAAsF,gBAAA,GACAtF,KAAAuF,eAAA,GACAvF,KAAAwF,eAAA,GACAxF,KAAAyF,gBAAA,GACAzF,KAAA0F,gBAAA,GAEA1F,KAAA2F,eAAAC,GAAAA,EAEA5F,KAAA6F,KAAA,iBAAAf,EAAAhB,QAAAgB,EAAAhB,QAAA,SACA,CAEAgC,UAAAC,EAAA3B,GAGA,GAAApE,KAAAoF,iBAAAtC,eAAAiD,EAAA1E,YAEA,OAAA,EAQA,OAJArB,KAAAkF,WAAAc,KAAAD,GACA/F,KAAAoF,iBAAAW,EAAA1E,aAAA,EAGA+C,GAEA,IAAA,QACApE,KAAAqF,gBAAAW,KAAAD,GACA,IAAA,QACA/F,KAAAsF,gBAAAU,KAAAD,GACA,IAAA,OACA/F,KAAAuF,eAAAS,KAAAD,GACA,IAAA,OACA/F,KAAAwF,eAAAQ,KAAAD,GACA,IAAA,QACA/F,KAAAyF,gBAAAO,KAAAD,GACA,IAAA,QACA/F,KAAA0F,gBAAAM,KAAAD,GAIA,OAAA,CACA,CAEAE,kBAAAC,GAIAlG,KAAA2F,eAFA,mBAAAO,EAEAA,EAIAN,GAAAA,CAEA,CAEAzD,MAAAgE,EAAAP,GAEA,MAAAQ,EAAApG,KAAA2F,eAAAC,GACA,IAAA,IAAArF,EAAA,EAAAA,EAAAP,KAAAqF,gBAAArE,OAAAT,IAEAP,KAAAqF,gBAAA9E,GAAA4B,MAAAgE,EAAAC,EAEA,CAEA7D,MAAA4D,EAAAP,GAEA,MAAAQ,EAAApG,KAAA2F,eAAAC,GACA,IAAA,IAAArF,EAAA,EAAAA,EAAAP,KAAAsF,gBAAAtE,OAAAT,IAEAP,KAAAsF,gBAAA/E,GAAAgC,MAAA4D,EAAAC,EAEA,CAEA5D,KAAA2D,EAAAP,GAEA,MAAAQ,EAAApG,KAAA2F,eAAAC,GACA,IAAA,IAAArF,EAAA,EAAAA,EAAAP,KAAAuF,eAAAvE,OAAAT,IAEAP,KAAAuF,eAAAhF,GAAAiC,KAAA2D,EAAAC,EAEA,CAEA3D,KAAA0D,EAAAP,GAEA,MAAAQ,EAAApG,KAAA2F,eAAAC,GACA,IAAA,IAAArF,EAAA,EAAAA,EAAAP,KAAAwF,eAAAxE,OAAAT,IAEAP,KAAAwF,eAAAjF,GAAAkC,KAAA0D,EAAAC,EAEA,CAEA1D,MAAAyD,EAAAP,GAEA,MAAAQ,EAAApG,KAAA2F,eAAAC,GACA,IAAA,IAAArF,EAAA,EAAAA,EAAAP,KAAAyF,gBAAAzE,OAAAT,IAEAP,KAAAyF,gBAAAlF,GAAAmC,MAAAyD,EAAAC,EAEA,CAEAzD,MAAAwD,EAAAP,GAEA,MAAAQ,EAAApG,KAAA2F,eAAAC,GACA,IAAA,IAAArF,EAAA,EAAAA,EAAAP,KAAA0F,gBAAA1E,OAAAT,IAEAP,KAAA0F,gBAAAnF,GAAAoC,MAAAwD,EAAAC,EAEA,CAEAlE,aAGA,IAAA,IAAA3B,EAAA,EAAAA,EAAAP,KAAAgF,mBAAAhE,OAAAT,IACA,CACA,IAAA8F,EAAAC,OAAAC,OAAA,CAAApD,WAAA,UAAAC,WAAA,UAAAC,MAAA,QAAArD,KAAAgF,mBAAAzE,IAEAP,KAAA+E,WAAAjC,eAAAuD,EAAAlD,YAMAnD,KAAA8F,UAAA,IAAA9F,KAAA+E,WAAAsB,EAAAlD,YAAAkD,EAAArG,MAAAqG,EAAAhD,OAJAJ,QAAAwB,IAAA,sEAAAC,KAAAC,UAAA0B,KAMA,CAGA,IAAA,IAAA9F,EAAA,EAAAA,EAAAP,KAAAkF,WAAAlE,OAAAT,IAEAP,KAAAkF,WAAA3E,GAAA2B,YAEA,CAEAsE,QAAAL,EAAAP,GAEA,IAAAa,OAAA,IAAAN,EAAAA,EAAA,OACAO,EAAA,IAAAjF,KACAzB,KAAAwC,KAAA,GAAAiE,KAAAC,aAAAA,KAAAd,EACA,CAGAe,eAEA,OAAA,IAAAlF,IACA,CAEAmF,aAAAC,GAGA,OADA,IAAApF,KACAoF,CACA,CAGAC,aAAAC,EAAAZ,EAAAP,GAEA,IAAAa,OAAA,IAAAN,EAAAA,EAAA,mBAGAa,GAAA,IAAAvF,KAEAzB,KAAAwC,KAAA,GAAAiE,uBAAAO,YAAAD,OAAAnB,EACA,CAEAqB,kBAAAF,EAAAZ,EAAAP,GAEA,IAAAa,OAAA,IAAAN,EAAAA,EAAA,mBAEAa,GAAA,IAAAvF,KAEAyF,EAAAC,SAAAJ,EAAA,KACAK,EAAAD,SAAAJ,EAAA,IAAA,IACAM,EAAAF,SAAAJ,EAAA,IAAA,IACAO,EAAAH,SAAAJ,EAAA,MAEAG,EAAAA,EAAA,GAAA,KAAAA,EAAAA,EAAA,IAAA,IAAAA,EAAAA,EACAE,EAAAA,EAAA,GAAA,IAAAA,EAAAA,EACAC,EAAAA,EAAA,GAAA,IAAAA,EAAAA,EACAC,EAAAA,EAAA,GAAA,IAAAA,EAAAA,EAEAtH,KAAAwC,KAAA,GAAAiE,uBAAAO,YAAAD,YAAAO,KAAAD,KAAAD,KAAAF,KAAAtB,EACA,CAEA2B,qBAAAC,EAAArB,EAAAP,GAEA5F,KAAA8G,aAAA9G,KAAA4G,aAAAY,GAAArB,EAAAP,EACA,CAEA6B,0BAAAD,EAAArB,EAAAP,GAEA5F,KAAAiH,kBAAAjH,KAAA4G,aAAAY,GAAArB,EAAAP,EACA,EAUAlG,EAAAD,QAAA,CAAAiI,IANA,SAAAC,GAEA,OAAA,IAAA1H,EAAA0H,EACA,EAGA1H,SAAAA,GACAP,EAAAD,QAAAmI,gBAAAnH,EAAA,4BLgNA,EAAE,CAAC,4BAA4B,EAAE,uCAAuC,EAAE,kCAAkC,KAAK,CAAC,EAAE,CAAC,GF9brH,CE8byH,EACzH","file":"fable-log.min.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","/**\n* Base Logger Class\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n*/\n\nclass BaseLogger\n{\n\tconstructor(pLogStreamSettings, pFableLog)\n\t{\n\t\t// This should not possibly be able to be instantiated without a settings object\n\t\tthis._Settings = (typeof(pLogStreamSettings) == 'object') ? pLogStreamSettings : {};\n\n\t\t// The base logger does nothing but associate a UUID with itself\n\t\t// We added this as the mechanism for tracking loggers to allow multiple simultaneous streams\n\t\t// to the same provider.\n\t\tthis.loggerUUID = this.generateInsecureUUID();\n\n\t\t// Eventually we can use this array to ompute which levels the provider allows.\n\t\t// For now it's just used to precompute some string concatenations.\n\t\tthis.levels = (\n\t\t\t[\n\t\t\t\t\"trace\",\n\t\t\t\t\"debug\",\n\t\t\t\t\"info\",\n\t\t\t\t\"warn\",\n\t\t\t\t\"error\",\n\t\t\t\t\"fatal\"\n\t\t\t]);\n\t}\n\n\t// This is meant to generate programmatically insecure UUIDs to identify loggers\n\tgenerateInsecureUUID()\n\t{\n\t\tlet tmpDate = new Date().getTime();\n\t\tlet tmpUUID = 'LOGSTREAM-xxxxxx-yxxxxx'.replace(/[xy]/g,\n\t\t\t\t(pCharacter) =>\n\t\t\t\t{\n\t\t\t\t\t// Funny algorithm from w3resource that is twister-ish without the deep math and security\n\t\t\t\t\t// ..but good enough for unique log stream identifiers\n\t\t\t\t\tlet tmpRandomData = (tmpDate + Math.random()*16)%16 | 0;\n\t\t\t\t\ttmpDate = Math.floor(tmpDate/16);\n\n\t\t\t\t\treturn (pCharacter =='x' ? tmpRandomData : (tmpRandomData&0x3|0x8)).toString(16);\n\t\t\t\t});\n\t\treturn tmpUUID;\n\t}\n\n\tinitialize()\n\t{\n\t\t// No operation.\n\t}\n\n\ttrace(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"trace\", pLogText, pLogObject);\n\t}\n\n\tdebug(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"debug\", pLogText, pLogObject);\n\t}\n\n\tinfo(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"info\", pLogText, pLogObject);\n\t}\n\n\twarn(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"warn\", pLogText, pLogObject);\n\t}\n\n\terror(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"error\", pLogText, pLogObject);\n\t}\n\n\tfatal(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"fatal\", pLogText, pLogObject);\n\t}\n\n\twrite(pLogLevel, pLogText, pLogObject)\n\t{\n\t\t// The base logger does nothing.\n\t\treturn true;\n\t}\n}\n\nmodule.exports = BaseLogger;\n","(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.FableLog = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\n/**\n* Base Logger Class\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n*/\n\nclass BaseLogger\n{\n\tconstructor(pLogStreamSettings, pFableLog)\n\t{\n\t\t// This should not possibly be able to be instantiated without a settings object\n\t\tthis._Settings = (typeof(pLogStreamSettings) == 'object') ? pLogStreamSettings : {};\n\n\t\t// The base logger does nothing but associate a UUID with itself\n\t\t// We added this as the mechanism for tracking loggers to allow multiple simultaneous streams\n\t\t// to the same provider.\n\t\tthis.loggerUUID = this.generateInsecureUUID();\n\n\t\t// Eventually we can use this array to ompute which levels the provider allows.\n\t\t// For now it's just used to precompute some string concatenations.\n\t\tthis.levels = (\n\t\t\t[\n\t\t\t\t\"trace\",\n\t\t\t\t\"debug\",\n\t\t\t\t\"info\",\n\t\t\t\t\"warn\",\n\t\t\t\t\"error\",\n\t\t\t\t\"fatal\"\n\t\t\t]);\n\t}\n\n\t// This is meant to generate programmatically insecure UUIDs to identify loggers\n\tgenerateInsecureUUID()\n\t{\n\t\tlet tmpDate = new Date().getTime();\n\t\tlet tmpUUID = 'LOGSTREAM-xxxxxx-yxxxxx'.replace(/[xy]/g,\n\t\t\t\t(pCharacter) =>\n\t\t\t\t{\n\t\t\t\t\t// Funny algorithm from w3resource that is twister-ish without the deep math and security\n\t\t\t\t\t// ..but good enough for unique log stream identifiers\n\t\t\t\t\tlet tmpRandomData = (tmpDate + Math.random()*16)%16 | 0;\n\t\t\t\t\ttmpDate = Math.floor(tmpDate/16);\n\n\t\t\t\t\treturn (pCharacter =='x' ? tmpRandomData : (tmpRandomData&0x3|0x8)).toString(16);\n\t\t\t\t});\n\t\treturn tmpUUID;\n\t}\n\n\tinitialize()\n\t{\n\t\t// No operation.\n\t}\n\n\ttrace(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"trace\", pLogText, pLogObject);\n\t}\n\n\tdebug(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"debug\", pLogText, pLogObject);\n\t}\n\n\tinfo(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"info\", pLogText, pLogObject);\n\t}\n\n\twarn(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"warn\", pLogText, pLogObject);\n\t}\n\n\terror(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"error\", pLogText, pLogObject);\n\t}\n\n\tfatal(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"fatal\", pLogText, pLogObject);\n\t}\n\n\twrite(pLogLevel, pLogText, pLogObject)\n\t{\n\t\t// The base logger does nothing.\n\t\treturn true;\n\t}\n}\n\nmodule.exports = BaseLogger;\n\n},{}],2:[function(require,module,exports){\n/**\n* Simple browser shim loader - assign the npm module to a window global automatically\n*\n* @license MIT\n* @author <steven@velozo.com>\n*/\nvar libNPMModuleWrapper = require('./Fable-Log.js');\n\nif ((typeof(window) === 'object') && !window.hasOwnProperty('FableLog'))\n{\n\twindow.FableLog = libNPMModuleWrapper;\n}\n\nmodule.exports = libNPMModuleWrapper;\n},{\"./Fable-Log.js\":6}],3:[function(require,module,exports){\n/**\n* Default Logger Provider Function\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n*/\n\n// Return the providers that are available without extensions loaded\ngetDefaultProviders = () =>\n{\n\tlet tmpDefaultProviders = {};\n\n\ttmpDefaultProviders.console = require('./Fable-Log-Logger-Console.js');\n\n\ttmpDefaultProviders.default = tmpDefaultProviders.console;\n\n\treturn tmpDefaultProviders;\n}\n\nmodule.exports = getDefaultProviders();\n},{\"./Fable-Log-Logger-Console.js\":5}],4:[function(require,module,exports){\nmodule.exports=[\n    {\n        \"loggertype\": \"console\",\n        \"streamtype\": \"console\",\n        \"level\": \"trace\"\n    }\n]\n},{}],5:[function(require,module,exports){\nlet libBaseLogger = require('./Fable-Log-BaseLogger.js');\n\nclass ConsoleLogger extends libBaseLogger\n{\n\tconstructor(pLogStreamSettings, pFableLog)\n\t{\n\t\tsuper(pLogStreamSettings);\n\n\t\tthis._ShowTimeStamps = this._Settings.hasOwnProperty('showtimestamps') ? (this._Settings.showtimestamps == true) : false;\n\t\tthis._FormattedTimeStamps = this._Settings.hasOwnProperty('formattedtimestamps') ? (this._Settings.formattedtimestamps == true) : false;\n\n\t\tthis._ContextMessage = this._Settings.hasOwnProperty('Context') ? `(${this._Settings.Context})` : \n\t\t\t\t\t\t\t\tpFableLog._Settings.hasOwnProperty('Product') ? `(${pFableLog._Settings.Product})` :\n\t\t\t\t\t\t\t\t'Unnamed_Log_Context';\n\n\t\t// Allow the user to decide what gets output to the console\n\t\tthis._OutputLogLinesToConsole = this._Settings.hasOwnProperty('outputloglinestoconsole') ? this._Settings.outputloglinestoconsole : true;\n\t\tthis._OutputObjectsToConsole = this._Settings.hasOwnProperty('outputobjectstoconsole') ? this._Settings.outputobjectstoconsole : true;\n\n\t\t// Precompute the prefix for each level\n\t\tthis.prefixCache = {};\n\t\tfor (let i = 0; i <= this.levels.length; i++)\n\t\t{\n\t\t\tthis.prefixCache[this.levels[i]] = `[${this.levels[i]}] ${this._ContextMessage}: `;\n\n\t\t\tif (this._ShowTimeStamps)\n\t\t\t{\n\t\t\t\t// If there is a timestamp we need a to prepend space before the prefixcache string, since the timestamp comes first\n\t\t\t\tthis.prefixCache[this.levels[i]] = ' '+this.prefixCache[this.levels[i]];\n\t\t\t}\n\t\t}\n\t}\n\n\twrite(pLevel, pLogText, pObject)\n\t{\n\t\tlet tmpTimeStamp = '';\n\t\tif (this._ShowTimeStamps && this._FormattedTimeStamps)\n\t\t{\n\t\t\ttmpTimeStamp = (new Date()).toISOString();\n\t\t}\n\t\telse if (this._ShowTimeStamps)\n\t\t{\n\t\t\ttmpTimeStamp = +new Date();\n\t\t}\n\n\t\tlet tmpLogLine = `${tmpTimeStamp}${this.prefixCache[pLevel]}${pLogText}`;\n\n\t\tif (this._OutputLogLinesToConsole)\n\t\t{\n\t\t\tconsole.log(tmpLogLine);\n\t\t}\n\n\t\t// Write out the object on a separate line if it is passed in\n\t\tif (this._OutputObjectsToConsole && (typeof(pObject) !== 'undefined'))\n\t\t{\n\t\t\tconsole.log(JSON.stringify(pObject, null, 2));\n\t\t}\n\n\t\t// Provide an easy way to be overridden and be consistent\n\t\treturn tmpLogLine;\n\t}\n}\n\nmodule.exports = ConsoleLogger;\n},{\"./Fable-Log-BaseLogger.js\":1}],6:[function(require,module,exports){\n/**\n* Fable Logging Add-on\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module Fable Logger\n*/\n\n/**\n* Fable Solution Log Wrapper Main Class\n*\n* @class FableLog\n* @constructor\n*/\nclass FableLog\n{\n\tconstructor(pFableSettings, pFable)\n\t{\n\t\tlet tmpSettings = (typeof(pFableSettings) === 'object') ? pFableSettings : {}\n\t\tthis._Settings = tmpSettings;\n\n\t\tthis._Providers = require('./Fable-Log-DefaultProviders-Node.js');\n\n\t\tthis._StreamDefinitions = (tmpSettings.hasOwnProperty('LogStreams')) ? tmpSettings.LogStreams : require('./Fable-Log-DefaultStreams.json');\n\n\t\tthis.logStreams = [];\n\n\t\t// This object gets decorated for one-time instantiated providers that\n\t\t//  have multiple outputs, such as bunyan.\n\t\tthis.logProviders = {};\n\n\t\t// A hash list of the GUIDs for each log stream, so they can't be added to the set more than one time\n\t\tthis.activeLogStreams = {};\n\n\t\tthis.logStreamsTrace = [];\n\t\tthis.logStreamsDebug = [];\n\t\tthis.logStreamsInfo = [];\n\t\tthis.logStreamsWarn = [];\n\t\tthis.logStreamsError = [];\n\t\tthis.logStreamsFatal = [];\n\n\t\tthis.datumDecorator = (pDatum) => pDatum;\n\n\t\tthis.uuid = (typeof(tmpSettings.Product) === 'string') ? tmpSettings.Product : 'Default';\n\t}\n\n\taddLogger(pLogger, pLevel)\n\t{\n\t\t// Bail out if we've already created one.\n\t\tif (this.activeLogStreams.hasOwnProperty(pLogger.loggerUUID))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\t// Add it to the streams and to the mutex\n\t\tthis.logStreams.push(pLogger);\n\t\tthis.activeLogStreams[pLogger.loggerUUID] = true;\n\n\t\t// Make sure a kosher level was passed in\n\t\tswitch (pLevel)\n\t\t{\n\t\t\tcase 'trace':\n\t\t\t\tthis.logStreamsTrace.push(pLogger);\n\t\t\tcase 'debug':\n\t\t\t\tthis.logStreamsDebug.push(pLogger);\n\t\t\tcase 'info':\n\t\t\t\tthis.logStreamsInfo.push(pLogger);\n\t\t\tcase 'warn':\n\t\t\t\tthis.logStreamsWarn.push(pLogger);\n\t\t\tcase 'error':\n\t\t\t\tthis.logStreamsError.push(pLogger);\n\t\t\tcase 'fatal':\n\t\t\t\tthis.logStreamsFatal.push(pLogger);\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tsetDatumDecorator(fDatumDecorator)\n\t{\n\t\tif (typeof(fDatumDecorator) === 'function')\n\t\t{\n\t\t\tthis.datumDecorator = fDatumDecorator;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.datumDecorator = (pDatum) => pDatum;\n\t\t}\n\t}\n\n\ttrace(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsTrace.length; i++)\n\t\t{\n\t\t\tthis.logStreamsTrace[i].trace(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\tdebug(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsDebug.length; i++)\n\t\t{\n\t\t\tthis.logStreamsDebug[i].debug(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\tinfo(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsInfo.length; i++)\n\t\t{\n\t\t\tthis.logStreamsInfo[i].info(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\twarn(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsWarn.length; i++)\n\t\t{\n\t\t\tthis.logStreamsWarn[i].warn(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\terror(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsError.length; i++)\n\t\t{\n\t\t\tthis.logStreamsError[i].error(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\tfatal(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsFatal.length; i++)\n\t\t{\n\t\t\tthis.logStreamsFatal[i].fatal(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\tinitialize()\n\t{\n\t\t// \"initialize\" each logger as defined in the logging parameters\n\t\tfor (let i = 0; i < this._StreamDefinitions.length; i++)\n\t\t{\n\t\t\tlet tmpStreamDefinition = Object.assign({loggertype:'default',streamtype:'console',level:'info'},this._StreamDefinitions[i]);\n\n\t\t\tif (!this._Providers.hasOwnProperty(tmpStreamDefinition.loggertype))\n\t\t\t{\n\t\t\t\tconsole.log(`Error initializing log stream: bad loggertype in stream definition ${JSON.stringify(tmpStreamDefinition)}`);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.addLogger(new this._Providers[tmpStreamDefinition.loggertype](tmpStreamDefinition, this), tmpStreamDefinition.level);\n\t\t\t}\n\t\t}\n\n\t\t// Now initialize each one.\n\t\tfor (let i = 0; i < this.logStreams.length; i++)\n\t\t{\n\t\t\tthis.logStreams[i].initialize();\n\t\t}\n\t}\n\n\tlogTime(pMessage, pDatum)\n\t{\n\t\tlet tmpMessage = (typeof(pMessage) !== 'undefined') ? pMessage : 'Time';\n\t\tlet tmpTime = new Date();\n\t\tthis.info(`${tmpMessage} ${tmpTime} (epoch ${+tmpTime})`, pDatum);\n\t}\n\n\t// Get a timestamp\n\tgetTimeStamp()\n\t{\n\t\treturn +new Date();\n\t}\n\n\tgetTimeDelta(pTimeStamp)\n\t{\n\t\tlet tmpEndTime = +new Date();\n\t\treturn tmpEndTime-pTimeStamp;\n\t}\n\n\t// Log the delta between a timestamp, and now with a message\n\tlogTimeDelta(pTimeDelta, pMessage, pDatum)\n\t{\n\t\tlet tmpMessage = (typeof(pMessage) !== 'undefined') ? pMessage : 'Time Measurement';\n\t\tlet tmpDatum = (typeof(pDatum) === 'object') ? pDatum : {};\n\n\t\tlet tmpEndTime = +new Date();\n\n\t\tthis.info(`${tmpMessage} logged at (epoch ${+tmpEndTime}) took (${pTimeDelta}ms)`, pDatum);\n\t}\n\n\tlogTimeDeltaHuman(pTimeDelta, pMessage, pDatum)\n\t{\n\t\tlet tmpMessage = (typeof(pMessage) !== 'undefined') ? pMessage : 'Time Measurement';\n\n\t\tlet tmpEndTime = +new Date();\n\n\t\tlet tmpMs = parseInt(pTimeDelta%1000);\n\t\tlet tmpSeconds = parseInt((pTimeDelta/1000)%60);\n\t\tlet tmpMinutes = parseInt((pTimeDelta/(1000*60))%60);\n\t\tlet tmpHours = parseInt(pTimeDelta/(1000*60*60));\n\n\t\ttmpMs = (tmpMs < 10) ? \"00\"+tmpMs : (tmpMs < 100) ? \"0\"+tmpMs : tmpMs;\n\t\ttmpSeconds = (tmpSeconds < 10) ? \"0\"+tmpSeconds : tmpSeconds;\n\t\ttmpMinutes = (tmpMinutes < 10) ? \"0\"+tmpMinutes : tmpMinutes;\n\t\ttmpHours = (tmpHours < 10) ? \"0\"+tmpHours : tmpHours;\n\n\t\tthis.info(`${tmpMessage} logged at (epoch ${+tmpEndTime}) took (${pTimeDelta}ms) or (${tmpHours}:${tmpMinutes}:${tmpSeconds}.${tmpMs})`, pDatum);\n\t}\n\n\tlogTimeDeltaRelative(pStartTime, pMessage, pDatum)\n\t{\n\t\tthis.logTimeDelta(this.getTimeDelta(pStartTime), pMessage, pDatum);\n\t}\n\n\tlogTimeDeltaRelativeHuman(pStartTime, pMessage, pDatum)\n\t{\n\t\tthis.logTimeDeltaHuman(this.getTimeDelta(pStartTime), pMessage, pDatum);\n\t}\n}\n\n// This is for backwards compatibility\nfunction autoConstruct(pSettings)\n{\n\treturn new FableLog(pSettings);\n}\n\n\nmodule.exports = {new:autoConstruct, FableLog:FableLog};\nmodule.exports.LogProviderBase = require('./Fable-Log-BaseLogger.js');\n\n},{\"./Fable-Log-BaseLogger.js\":1,\"./Fable-Log-DefaultProviders-Node.js\":3,\"./Fable-Log-DefaultStreams.json\":4}]},{},[2])(2)\n});\n\n","/**\n* Simple browser shim loader - assign the npm module to a window global automatically\n*\n* @license MIT\n* @author <steven@velozo.com>\n*/\nvar libNPMModuleWrapper = require('./Fable-Log.js');\n\nif ((typeof(window) === 'object') && !window.hasOwnProperty('FableLog'))\n{\n\twindow.FableLog = libNPMModuleWrapper;\n}\n\nmodule.exports = libNPMModuleWrapper;","/**\n* Default Logger Provider Function\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n*/\n\n// Return the providers that are available without extensions loaded\ngetDefaultProviders = () =>\n{\n\tlet tmpDefaultProviders = {};\n\n\ttmpDefaultProviders.console = require('./Fable-Log-Logger-Console.js');\n\n\ttmpDefaultProviders.default = tmpDefaultProviders.console;\n\n\treturn tmpDefaultProviders;\n}\n\nmodule.exports = getDefaultProviders();","module.exports=[\n    {\n        \"loggertype\": \"console\",\n        \"streamtype\": \"console\",\n        \"level\": \"trace\"\n    }\n]","let libBaseLogger = require('./Fable-Log-BaseLogger.js');\n\nclass ConsoleLogger extends libBaseLogger\n{\n\tconstructor(pLogStreamSettings, pFableLog)\n\t{\n\t\tsuper(pLogStreamSettings);\n\n\t\tthis._ShowTimeStamps = this._Settings.hasOwnProperty('showtimestamps') ? (this._Settings.showtimestamps == true) : false;\n\t\tthis._FormattedTimeStamps = this._Settings.hasOwnProperty('formattedtimestamps') ? (this._Settings.formattedtimestamps == true) : false;\n\n\t\tthis._ContextMessage = this._Settings.hasOwnProperty('Context') ? `(${this._Settings.Context})` : \n\t\t\t\t\t\t\t\tpFableLog._Settings.hasOwnProperty('Product') ? `(${pFableLog._Settings.Product})` :\n\t\t\t\t\t\t\t\t'Unnamed_Log_Context';\n\n\t\t// Allow the user to decide what gets output to the console\n\t\tthis._OutputLogLinesToConsole = this._Settings.hasOwnProperty('outputloglinestoconsole') ? this._Settings.outputloglinestoconsole : true;\n\t\tthis._OutputObjectsToConsole = this._Settings.hasOwnProperty('outputobjectstoconsole') ? this._Settings.outputobjectstoconsole : true;\n\n\t\t// Precompute the prefix for each level\n\t\tthis.prefixCache = {};\n\t\tfor (let i = 0; i <= this.levels.length; i++)\n\t\t{\n\t\t\tthis.prefixCache[this.levels[i]] = `[${this.levels[i]}] ${this._ContextMessage}: `;\n\n\t\t\tif (this._ShowTimeStamps)\n\t\t\t{\n\t\t\t\t// If there is a timestamp we need a to prepend space before the prefixcache string, since the timestamp comes first\n\t\t\t\tthis.prefixCache[this.levels[i]] = ' '+this.prefixCache[this.levels[i]];\n\t\t\t}\n\t\t}\n\t}\n\n\twrite(pLevel, pLogText, pObject)\n\t{\n\t\tlet tmpTimeStamp = '';\n\t\tif (this._ShowTimeStamps && this._FormattedTimeStamps)\n\t\t{\n\t\t\ttmpTimeStamp = (new Date()).toISOString();\n\t\t}\n\t\telse if (this._ShowTimeStamps)\n\t\t{\n\t\t\ttmpTimeStamp = +new Date();\n\t\t}\n\n\t\tlet tmpLogLine = `${tmpTimeStamp}${this.prefixCache[pLevel]}${pLogText}`;\n\n\t\tif (this._OutputLogLinesToConsole)\n\t\t{\n\t\t\tconsole.log(tmpLogLine);\n\t\t}\n\n\t\t// Write out the object on a separate line if it is passed in\n\t\tif (this._OutputObjectsToConsole && (typeof(pObject) !== 'undefined'))\n\t\t{\n\t\t\tconsole.log(JSON.stringify(pObject, null, 2));\n\t\t}\n\n\t\t// Provide an easy way to be overridden and be consistent\n\t\treturn tmpLogLine;\n\t}\n}\n\nmodule.exports = ConsoleLogger;","/**\n* Fable Logging Add-on\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module Fable Logger\n*/\n\n/**\n* Fable Solution Log Wrapper Main Class\n*\n* @class FableLog\n* @constructor\n*/\nclass FableLog\n{\n\tconstructor(pFableSettings, pFable)\n\t{\n\t\tlet tmpSettings = (typeof(pFableSettings) === 'object') ? pFableSettings : {}\n\t\tthis._Settings = tmpSettings;\n\n\t\tthis._Providers = require('./Fable-Log-DefaultProviders-Node.js');\n\n\t\tthis._StreamDefinitions = (tmpSettings.hasOwnProperty('LogStreams')) ? tmpSettings.LogStreams : require('./Fable-Log-DefaultStreams.json');\n\n\t\tthis.logStreams = [];\n\n\t\t// This object gets decorated for one-time instantiated providers that\n\t\t//  have multiple outputs, such as bunyan.\n\t\tthis.logProviders = {};\n\n\t\t// A hash list of the GUIDs for each log stream, so they can't be added to the set more than one time\n\t\tthis.activeLogStreams = {};\n\n\t\tthis.logStreamsTrace = [];\n\t\tthis.logStreamsDebug = [];\n\t\tthis.logStreamsInfo = [];\n\t\tthis.logStreamsWarn = [];\n\t\tthis.logStreamsError = [];\n\t\tthis.logStreamsFatal = [];\n\n\t\tthis.datumDecorator = (pDatum) => pDatum;\n\n\t\tthis.uuid = (typeof(tmpSettings.Product) === 'string') ? tmpSettings.Product : 'Default';\n\t}\n\n\taddLogger(pLogger, pLevel)\n\t{\n\t\t// Bail out if we've already created one.\n\t\tif (this.activeLogStreams.hasOwnProperty(pLogger.loggerUUID))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\t// Add it to the streams and to the mutex\n\t\tthis.logStreams.push(pLogger);\n\t\tthis.activeLogStreams[pLogger.loggerUUID] = true;\n\n\t\t// Make sure a kosher level was passed in\n\t\tswitch (pLevel)\n\t\t{\n\t\t\tcase 'trace':\n\t\t\t\tthis.logStreamsTrace.push(pLogger);\n\t\t\tcase 'debug':\n\t\t\t\tthis.logStreamsDebug.push(pLogger);\n\t\t\tcase 'info':\n\t\t\t\tthis.logStreamsInfo.push(pLogger);\n\t\t\tcase 'warn':\n\t\t\t\tthis.logStreamsWarn.push(pLogger);\n\t\t\tcase 'error':\n\t\t\t\tthis.logStreamsError.push(pLogger);\n\t\t\tcase 'fatal':\n\t\t\t\tthis.logStreamsFatal.push(pLogger);\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tsetDatumDecorator(fDatumDecorator)\n\t{\n\t\tif (typeof(fDatumDecorator) === 'function')\n\t\t{\n\t\t\tthis.datumDecorator = fDatumDecorator;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.datumDecorator = (pDatum) => pDatum;\n\t\t}\n\t}\n\n\ttrace(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsTrace.length; i++)\n\t\t{\n\t\t\tthis.logStreamsTrace[i].trace(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\tdebug(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsDebug.length; i++)\n\t\t{\n\t\t\tthis.logStreamsDebug[i].debug(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\tinfo(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsInfo.length; i++)\n\t\t{\n\t\t\tthis.logStreamsInfo[i].info(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\twarn(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsWarn.length; i++)\n\t\t{\n\t\t\tthis.logStreamsWarn[i].warn(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\terror(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsError.length; i++)\n\t\t{\n\t\t\tthis.logStreamsError[i].error(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\tfatal(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsFatal.length; i++)\n\t\t{\n\t\t\tthis.logStreamsFatal[i].fatal(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\tinitialize()\n\t{\n\t\t// \"initialize\" each logger as defined in the logging parameters\n\t\tfor (let i = 0; i < this._StreamDefinitions.length; i++)\n\t\t{\n\t\t\tlet tmpStreamDefinition = Object.assign({loggertype:'default',streamtype:'console',level:'info'},this._StreamDefinitions[i]);\n\n\t\t\tif (!this._Providers.hasOwnProperty(tmpStreamDefinition.loggertype))\n\t\t\t{\n\t\t\t\tconsole.log(`Error initializing log stream: bad loggertype in stream definition ${JSON.stringify(tmpStreamDefinition)}`);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.addLogger(new this._Providers[tmpStreamDefinition.loggertype](tmpStreamDefinition, this), tmpStreamDefinition.level);\n\t\t\t}\n\t\t}\n\n\t\t// Now initialize each one.\n\t\tfor (let i = 0; i < this.logStreams.length; i++)\n\t\t{\n\t\t\tthis.logStreams[i].initialize();\n\t\t}\n\t}\n\n\tlogTime(pMessage, pDatum)\n\t{\n\t\tlet tmpMessage = (typeof(pMessage) !== 'undefined') ? pMessage : 'Time';\n\t\tlet tmpTime = new Date();\n\t\tthis.info(`${tmpMessage} ${tmpTime} (epoch ${+tmpTime})`, pDatum);\n\t}\n\n\t// Get a timestamp\n\tgetTimeStamp()\n\t{\n\t\treturn +new Date();\n\t}\n\n\tgetTimeDelta(pTimeStamp)\n\t{\n\t\tlet tmpEndTime = +new Date();\n\t\treturn tmpEndTime-pTimeStamp;\n\t}\n\n\t// Log the delta between a timestamp, and now with a message\n\tlogTimeDelta(pTimeDelta, pMessage, pDatum)\n\t{\n\t\tlet tmpMessage = (typeof(pMessage) !== 'undefined') ? pMessage : 'Time Measurement';\n\t\tlet tmpDatum = (typeof(pDatum) === 'object') ? pDatum : {};\n\n\t\tlet tmpEndTime = +new Date();\n\n\t\tthis.info(`${tmpMessage} logged at (epoch ${+tmpEndTime}) took (${pTimeDelta}ms)`, pDatum);\n\t}\n\n\tlogTimeDeltaHuman(pTimeDelta, pMessage, pDatum)\n\t{\n\t\tlet tmpMessage = (typeof(pMessage) !== 'undefined') ? pMessage : 'Time Measurement';\n\n\t\tlet tmpEndTime = +new Date();\n\n\t\tlet tmpMs = parseInt(pTimeDelta%1000);\n\t\tlet tmpSeconds = parseInt((pTimeDelta/1000)%60);\n\t\tlet tmpMinutes = parseInt((pTimeDelta/(1000*60))%60);\n\t\tlet tmpHours = parseInt(pTimeDelta/(1000*60*60));\n\n\t\ttmpMs = (tmpMs < 10) ? \"00\"+tmpMs : (tmpMs < 100) ? \"0\"+tmpMs : tmpMs;\n\t\ttmpSeconds = (tmpSeconds < 10) ? \"0\"+tmpSeconds : tmpSeconds;\n\t\ttmpMinutes = (tmpMinutes < 10) ? \"0\"+tmpMinutes : tmpMinutes;\n\t\ttmpHours = (tmpHours < 10) ? \"0\"+tmpHours : tmpHours;\n\n\t\tthis.info(`${tmpMessage} logged at (epoch ${+tmpEndTime}) took (${pTimeDelta}ms) or (${tmpHours}:${tmpMinutes}:${tmpSeconds}.${tmpMs})`, pDatum);\n\t}\n\n\tlogTimeDeltaRelative(pStartTime, pMessage, pDatum)\n\t{\n\t\tthis.logTimeDelta(this.getTimeDelta(pStartTime), pMessage, pDatum);\n\t}\n\n\tlogTimeDeltaRelativeHuman(pStartTime, pMessage, pDatum)\n\t{\n\t\tthis.logTimeDeltaHuman(this.getTimeDelta(pStartTime), pMessage, pDatum);\n\t}\n}\n\n// This is for backwards compatibility\nfunction autoConstruct(pSettings)\n{\n\treturn new FableLog(pSettings);\n}\n\n\nmodule.exports = {new:autoConstruct, FableLog:FableLog};\nmodule.exports.LogProviderBase = require('./Fable-Log-BaseLogger.js');\n"]}